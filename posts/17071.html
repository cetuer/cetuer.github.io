<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/logo.png"><link rel="icon" href="/img/logo.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests"><meta name="theme-color" content="#2f4154"><meta name="author" content="Cetuer"><meta name="keywords" content="Java, 源码阅读, 算法, Java框架, 心得, Spring, Spring Boot, Spring Cloud, Spring Cloud Alibaba"><meta name="description" content="如果把类继承关系抽象成一棵树，那么 Object 类是这棵树的根节点。所以 Object 类是所有类的超类。所有对象，包括数组，都实现了这个类的方法。 比如下面这行代码是合法的： 1Object obj &#x3D; new int[5];  但是请注意，由于基础类型并不是类，所以基础数据类型没有所谓的父类，Object 类更不是基础数据类型的父类。 1. registerNatives1234privat"><meta property="og:type" content="article"><meta property="og:title" content="Object源码分析"><meta property="og:url" content="https://cetuer.github.io/posts/17071.html"><meta property="og:site_name" content="Cetuer"><meta property="og:description" content="如果把类继承关系抽象成一棵树，那么 Object 类是这棵树的根节点。所以 Object 类是所有类的超类。所有对象，包括数组，都实现了这个类的方法。 比如下面这行代码是合法的： 1Object obj &#x3D; new int[5];  但是请注意，由于基础类型并不是类，所以基础数据类型没有所谓的父类，Object 类更不是基础数据类型的父类。 1. registerNatives1234privat"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cetuer.github.io/posts/17071/716271-20170320112245721-1831918220.jpg"><meta property="article:published_time" content="2023-01-17T08:53:50.000Z"><meta property="article:modified_time" content="2023-01-17T08:53:50.000Z"><meta property="article:author" content="Cetuer"><meta property="article:tag" content="源码分析"><meta property="article:tag" content="JDK源码"><meta property="article:tag" content="基础类"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://cetuer.github.io/posts/17071/716271-20170320112245721-1831918220.jpg"><meta name="referrer" content="no-referrer-when-downgrade"><title>Object源码分析 - Cetuer</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var CONFIG={hostname:"cetuer.github.io",root:"/",version:"1.9.3",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!1,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"};if(CONFIG.web_analytics.follow_dnt){var dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack;Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on"))}</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.3.0"></head><body><header><div class="header-inner" style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Cetuer</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/default.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="Object源码分析"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2023-01-17 16:53" pubdate>2023年1月17日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 4.6k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 39 分钟 </span><span id="busuanzi_container_page_pv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">Object源码分析</h1><div class="markdown-body"><p>如果把类继承关系抽象成一棵树，那么 <code>Object</code> 类是这棵树的根节点。所以 <code>Object</code> 类是所有类的超类。所有对象，包括数组，都实现了这个类的方法。</p><p>比如下面这行代码是合法的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">5</span>];<br></code></pre></td></tr></table></figure><p>但是<strong>请注意</strong>，由于基础类型并不是类，所以基础数据类型没有所谓的父类，<code>Object</code> 类更不是基础数据类型的父类。</p><h1 id="1-registerNatives"><a href="#1-registerNatives" class="headerlink" title="1. registerNatives"></a>1. registerNatives</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerNatives</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">static</span> &#123;<br>    registerNatives();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>static</code> 代码块会在类加载后首先执行，然后调用 <code>registerNatives</code> 方法，而本方法的作用是注册本地方法，所以 <code>Object</code> 类被加载后会立即注册类中的所有本地方法。</p><p>这里简单介绍一下本地方法的含义，<code>Java</code> 中本地方法指的是使用 <code>native</code> 关键字修饰的方法，本地方法没有方法体，因为本地方法的实现是由其它语言编写的。本地方法保存在动态链接库中，格式是各个平台特有的，所以本地方法并不是平台无关的。</p><p>一个 <code>Java</code> 程序想要调用一个本地方法需要分为两步：</p><ol><li>通过 <code>System.loadLibrary()</code> 方法将包含本地方法实现的动态文件加载到内存。</li><li>运行中的 <code>Java</code> 程序调用本地方法时，虚拟机在加载的动态文件中定位并链接该本地方法，从而得以执行本地方法。</li></ol><p><code>registerNatives</code> 方法的作用就是取代第二步，让程序主动将本地方法链接到调用方，当Java程序需要调用本地方法时就可以直接调用，而不需要虚拟机再去定位并链接。</p><h1 id="2-getClass"><a href="#2-getClass" class="headerlink" title="2. getClass"></a>2. getClass</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> Class&lt;?&gt; getClass();<br></code></pre></td></tr></table></figure><p><code>getClass</code> 方法的作用是返回此 <code>Object</code> 的运行时类。返回的 <code>Class</code> 对象是被 <code>static synchronized</code> 锁定的对象。所以同一个类的任何一个实例调用本方法返回的对象都是同一个，下面的小例子可以证明这一点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">&quot;1&quot;</span>.getClass() == <span class="hljs-string">&quot;2&quot;</span>.getClass());<br></code></pre></td></tr></table></figure><p>由于 <code>&quot;1&quot;</code> 和 <code>&quot;2&quot;</code> 都是 <code>String</code> 类的实例，所以他们的运行时类对象都是同一个，所以上面的代码输出结果是 <code>true</code> 。</p><p>对于带有泛型的对象来说，此方法返回的实际结果类型是 <strong>Class&lt;? extends |X|&gt;</strong> ，其中 <strong>|X|</strong> 是调用 <code>getClass</code> 的表达式的静态类型的擦除。例如，此代码片段中不需要强转：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Number</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <br>Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Number</span>&gt; c = n.getClass();<br></code></pre></td></tr></table></figure><p>上面那句话是官方说明，这里我简单解读下意思，就是说，对于具有 <code>T</code> 类型的变量时 <code>&lt;T extends Number&gt;</code> ，可以有多个类可以继承 <code>Number</code> ，例如 <code>Integer</code> ， 能够满足 <code>T extends Number</code> 条件。由于泛型擦除，没有运行时信息，就不知道具体传递了哪个具体实现子类。因此，为了提供一个通用的解决方案，它会返回 <code>&lt;? extends Number&gt;</code>，因为无论传入什么类实例，它都适用于 <code>Number</code> 的任何子类，例如将上面代码中的 <code>Number n = 0;</code> 改为 <code>Integer n = 0;</code> 也是正确的。</p><h1 id="3-hashCode"><a href="#3-hashCode" class="headerlink" title="3. hashCode"></a>3. hashCode</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><p><code>hashCode</code> 方法的作用是返回本对象的哈希码值。支持此方法是为了哈希表更好实现，例如 <code>java.util.HashMap</code> 提供的哈希表。<br><code>hashCode</code> 的一般约定是：</p><ul><li>程序运行期间多次调用同一个对象的 <code>hashCode</code> ，那么必须返回相同的整数，前提是在对象的 <code>equals</code> 比较中使用的信息没有被修改。如果启动两次程序，返回不需要保持一致。</li><li>如果 <code>equals()</code> 方法两个对象相等，则对这两个对象中的任一个调用 <code>hashCode</code> 方法返回值一致。</li><li>如果 <code>equals()</code> 方法两个对象不相等，不要求 <code>hashCode</code>方法都必须产生不同的结果。但是，程序员应该知道，为不相等的对象生成不同的整数结果可能会提高哈希表的性能。</li></ul><p>在普通情况下，<code>Object</code> 定义的 <code>hashCode</code> 方法确实会为不同的对象返回不同的整数。</p><h1 id="4-equals"><a href="#4-equals" class="headerlink" title="4. equals"></a>4. equals</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span> &#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">this</span> == obj);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>equals</code> 方法是经常会用到的方法了，用来判断某个其他对象是否 <strong>等于</strong> 这个对象，方法入参是需要对比的另一个对象。<br><code>equals</code> 方法在非空对象引用上实现有几个特性：</p><ul><li>自反性：对于任何非空引用值 <code>x</code> ， <code>x.equals(x)</code> 应该返回 <code>true</code> 。</li><li>对称性：对于任何非空引用值 <code>x</code> 和 <code>y</code> ，若 <code>x.equals(y)</code> 返回 <code>true</code> ，则 <code>y.equals(x)</code> 也返回 <code>true</code> 。</li><li>可传递性：对于任何非空引用值 <code>x</code> 、 <code>y</code> 和 <code>z</code> ，如果 <code>x.equals(y)</code> 返回 <code>true</code> 并且 <code>y.equals(z)</code> 返回 <code>true</code> ，那么 <code>x.equals(z)</code> 也应该返回true 。</li><li>一致性：对于任何非空引用值 <code>x</code> 和 <code>y</code> ，多次调用 <code>x.equals(y)</code> 始终返回 <code>true</code> 或始终返回 <code>false</code> ，前提是在对象的 <code>equals</code> 比较中使用的信息没有被修改。</li><li>对于任何非空引用值 <code>x</code> ， <code>x.equals(null)</code> 应该返回 <code>false</code> 。</li></ul><p><code>Object</code> 的 <code>equals</code> 方法实现方式直接判断两个对象的内存地址是否一致。<br>通常需要在重写此方法时重写 <code>hashCode</code> 方法，以维护 <code>hashCode</code> 方法的一般约定。</p><h1 id="5-clone"><a href="#5-clone" class="headerlink" title="5. clone"></a>5. clone</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException;<br></code></pre></td></tr></table></figure><p><code>clone</code> 方法创建并返回此对象的副本。</p><p>此方法访问属性是 <code>protected</code> 的，只有子类和同包类可以 访问，而 <code>Object</code> 类又是 <code>java.lang</code> 包下的，所以一般来说 <code>Object</code> 类的 <code>clone</code> 方法是没办法直接调用的，都是通过子类去调用。如果该对象的类没有实现 <code>Cloneable</code> 接口，则会抛出 <code>CloneNotSupportedException</code> ，由于 <code>Object</code> 并没有实现 <code>Cloneable</code> 接口，所以即使调用了 <code>Object</code> 的 <code>clone</code> 方法也会抛出异常。</p><p>所有数组都被视为实现接口 <code>Cloneable</code> ，并且数组类型 <code>T []</code> 的clone方法的返回类型是 <code>T []</code> ，其中 <code>T</code> 是任何引用或原始类型。</p><p>注意，此方法 <strong>默认是浅拷贝</strong>。</p><h1 id="6-toString"><a href="#6-toString" class="headerlink" title="6. toString"></a>6. toString</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> getClass().getName() + <span class="hljs-string">&quot;@&quot;</span> + Integer.toHexString(hashCode());<br>&#125;<br></code></pre></td></tr></table></figure><p><code>toString</code> 用来返回对象的字符串表示形式。通常， <code>toString</code> 方法返回一个 <em>文本表示</em> 此对象的字符串。结果应该是简洁但信息丰富的表示形式，易于人们阅读。建议所有子类重写此方法。<br><code>Object</code> 类的 <code>toString</code> 方法返回一个字符串，该字符串由全类名(包名+类名)、 <em>@</em> 和哈希的无符号十六进制形式组成。</p><p>普通自定义类的输出像下面这样：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-keyword">com</span>.cetuer.Demo<span class="hljs-subst">@74</span>a14482<br></code></pre></td></tr></table></figure><p>但是如果是数组，输出将会有很大区别。</p><p>对象数组像这样：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">[Ljava.lang.String<span class="hljs-comment">;@1540e19d</span><br></code></pre></td></tr></table></figure><p>基础类型数组像这样：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[I<span class="hljs-symbol">@677327b6</span><br></code></pre></td></tr></table></figure><p>二维数组像这样：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[[I<span class="hljs-symbol">@677327b6</span><br></code></pre></td></tr></table></figure><p>实际上，数组的全类名是比较特殊的，首先由 <code>[</code> 来表明这是个数组形式，几个 <code>[</code> 就代表着是几维数组，后面紧跟着的一个字母代表这个数组的类型，可能是：L（对象类型）、Z（boolean类型）、B（对象类型）、S（boolean类型）、C（对象类型）、I（boolean类型）、J（对象类型）、F（boolean类型）、D（对象类型）。如果是对象类型的话，紧跟着的是全类名加一个分号。</p><h1 id="7-notify与wait"><a href="#7-notify与wait" class="headerlink" title="7. notify与wait"></a>7. notify与wait</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 随机唤醒持有相同锁的单个线程</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">()</span>;<br><span class="hljs-comment">// 唤醒所有线程</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyAll</span><span class="hljs-params">()</span>;<br><span class="hljs-comment">// 使当前线程等待timeout秒后自动唤醒</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br><span class="hljs-comment">// 使当前线程等待</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    wait(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-comment">// 等待时间加额外等待时间，取近似值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, <span class="hljs-type">int</span> nanos)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">if</span> (timeout &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;timeout value is negative&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (nanos &lt; <span class="hljs-number">0</span> || nanos &gt; <span class="hljs-number">999999</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<br>            <span class="hljs-string">&quot;nanosecond timeout value out of range&quot;</span>);<br>    &#125;<br>	<span class="hljs-comment">// 额外等待时间大于0就近似的加1毫秒</span><br>    <span class="hljs-keyword">if</span> (nanos &gt; <span class="hljs-number">0</span>) &#123;<br>        timeout++;<br>    &#125;<br><br>    wait(timeout);<br>&#125;<br></code></pre></td></tr></table></figure><p>在解读之前先放一张线程状态图：</p><p><img src="/posts/17071/716271-20170320112245721-1831918220.jpg" srcset="/img/loading.gif" lazyload alt="线程状态图"></p><ul><li><p><strong>wait(long timeout)<strong>：从</strong>调用处</strong>使当前线程在对象的监视器上等待，直到另一个线程为此对象调用 <code>notify()</code> 方法或 <code>notifyAll()</code> 方法来唤醒此线程，或者经过 <code>timeout</code> 时间后自动唤醒，若 <code>timeout</code> 为0则只能通过其它线程唤醒，若被中断则抛出 <code>InterruptedException</code> 异常。</p><p>从线程状态图中可以看到调用 <code>wait</code> 后线程状态从运行状态变为了等待状态。</p></li><li><p><strong>wait()</strong> ：<code>wait</code> 的重载，传递 <code>timeout</code> 为 0，不会超时自动唤醒。</p></li><li><p>**wait(long timeout, int nanos)**：<code>wait</code> 的重载，多传递了一个纳秒，从源码看如果传递了纳秒则超时时间加一毫秒，并且做了一些数值合法验证。</p></li><li><p>**notify()**：唤醒在此对象监视器上等待的单个线程。如果有多个线程正在等待该对象，则随机选择唤醒其中一个线程。</p><p>从线程状态图中可以看到调用 <code>notify</code> 后线程状态从等待状态变为了锁定状态，在拿到同步锁并且被调度后便又重新变为执行状态了。</p></li><li><p>**notifyAll()**：唤醒在此对象的监视器上等待的所有线程。</p></li></ul><h1 id="8-finalize"><a href="#8-finalize" class="headerlink" title="8. finalize"></a>8. finalize</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123; &#125;<br></code></pre></td></tr></table></figure><p>当垃圾收集器回收此对象前会执行 <code>finalize</code> 方法。子类重写 <code>finalize</code> 方法以处理系统资源或执行其他清理。<code>Java</code> 虚拟机永远不会多次调用 <code>finalize</code> 方法。</p><p>简单来说其实就是在执行 <code>gc</code> 前调用的一个方法，但是不保证里面的方法会被执行完。</p></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="category-chain-item">源码分析</a> <span>></span> <a href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/JDK%E6%BA%90%E7%A0%81/" class="category-chain-item">JDK源码</a> <span>></span> <a href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/JDK%E6%BA%90%E7%A0%81/%E5%9F%BA%E7%A1%80%E7%B1%BB/" class="category-chain-item">基础类</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">#源码分析</a> <a href="/tags/JDK%E6%BA%90%E7%A0%81/">#JDK源码</a> <a href="/tags/%E5%9F%BA%E7%A1%80%E7%B1%BB/">#基础类</a></div></div><div class="license-box my-3"><div class="license-title"><div>Object源码分析</div><div>https://cetuer.github.io/posts/17071.html</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>Cetuer</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2023年1月17日</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"></article><article class="post-next col-6"><a href="/posts/24660.html" title="CAP原则与BASE理论"><span class="hidden-mobile">CAP原则与BASE理论</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="busuanzi_container_site_pv" style="display:none">总访问量 <span id="busuanzi_value_site_pv"></span> 次 </span><span id="busuanzi_container_site_uv" style="display:none">总访客数 <span id="busuanzi_value_site_uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",(function(){NProgress.done()}))</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t,e){var i=Fluid.plugins.typing,n=e.getElementById("subtitle");n&&i&&i(n.getAttribute("data-typed-text"))}(window,document)</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",(function(){var t=jQuery("#toc");if(0!==t.length&&window.tocbot){var i=jQuery("#board-ctn").offset().top;window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-i},CONFIG.toc)),t.find(".toc-list-item").length>0&&t.css("visibility","visible"),Fluid.events.registerRefreshCallback((function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;t.find(".toc-list-item").length>0&&t.css("visibility","visible")}}))}}))</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js",(function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback((function(){if("anchors"in window){anchors.removeAll();var n=(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","),o=[];for(var s of n)o.push(".markdown-body > "+s.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}}))}))</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",(function(){Fluid.plugins.fancyBox()}))</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/live2d/autoload.js"></script><script src="/love.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>