<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Object源码分析</title>
    <link href="/posts/17071.html"/>
    <url>/posts/17071.html</url>
    
    <content type="html"><![CDATA[<p>如果把类继承关系抽象成一棵树，那么 <code>Object</code> 类是这棵树的根节点。所以 <code>Object</code> 类是所有类的超类。所有对象，包括数组，都实现了这个类的方法。</p><p>比如下面这行代码是合法的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">5</span>];<br></code></pre></td></tr></table></figure><p>但是<strong>请注意</strong>，由于基础类型并不是类，所以基础数据类型没有所谓的父类，<code>Object</code> 类更不是基础数据类型的父类。</p><h1 id="1-registerNatives"><a href="#1-registerNatives" class="headerlink" title="1. registerNatives"></a>1. registerNatives</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerNatives</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">static</span> &#123;<br>    registerNatives();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>static</code> 代码块会在类加载后首先执行，然后调用 <code>registerNatives</code> 方法，而本方法的作用是注册本地方法，所以 <code>Object</code> 类被加载后会立即注册类中的所有本地方法。</p><p>这里简单介绍一下本地方法的含义，<code>Java</code> 中本地方法指的是使用 <code>native</code> 关键字修饰的方法，本地方法没有方法体，因为本地方法的实现是由其它语言编写的。本地方法保存在动态链接库中，格式是各个平台特有的，所以本地方法并不是平台无关的。</p><p>一个 <code>Java</code> 程序想要调用一个本地方法需要分为两步：</p><ol><li>通过 <code>System.loadLibrary()</code> 方法将包含本地方法实现的动态文件加载到内存。</li><li>运行中的 <code>Java</code> 程序调用本地方法时，虚拟机在加载的动态文件中定位并链接该本地方法，从而得以执行本地方法。</li></ol><p><code>registerNatives</code> 方法的作用就是取代第二步，让程序主动将本地方法链接到调用方，当Java程序需要调用本地方法时就可以直接调用，而不需要虚拟机再去定位并链接。</p><h1 id="2-getClass"><a href="#2-getClass" class="headerlink" title="2. getClass"></a>2. getClass</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> Class&lt;?&gt; getClass();<br></code></pre></td></tr></table></figure><p><code>getClass</code> 方法的作用是返回此 <code>Object</code> 的运行时类。返回的 <code>Class</code> 对象是被 <code>static synchronized</code> 锁定的对象。所以同一个类的任何一个实例调用本方法返回的对象都是同一个，下面的小例子可以证明这一点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-string">&quot;1&quot;</span>.getClass() == <span class="hljs-string">&quot;2&quot;</span>.getClass());<br></code></pre></td></tr></table></figure><p>由于 <code>&quot;1&quot;</code> 和 <code>&quot;2&quot;</code> 都是 <code>String</code> 类的实例，所以他们的运行时类对象都是同一个，所以上面的代码输出结果是 <code>true</code> 。</p><p>对于带有泛型的对象来说，此方法返回的实际结果类型是 <strong>Class&lt;? extends |X|&gt;</strong> ，其中 <strong>|X|</strong> 是调用 <code>getClass</code>  的表达式的静态类型的擦除。例如，此代码片段中不需要强转：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Number</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <br>Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Number</span>&gt; c = n.getClass();<br></code></pre></td></tr></table></figure><p>上面那句话是官方说明，这里我简单解读下意思，就是说，对于具有 <code>T</code> 类型的变量时 <code>&lt;T extends Number&gt;</code> ，可以有多个类可以继承 <code>Number</code> ，例如 <code>Integer</code> ， 能够满足 <code>T extends Number</code> 条件。由于泛型擦除，没有运行时信息，就不知道具体传递了哪个具体实现子类。因此，为了提供一个通用的解决方案，它会返回 <code>&lt;? extends Number&gt;</code>，因为无论传入什么类实例，它都适用于 <code>Number</code> 的任何子类，例如将上面代码中的 <code>Number n = 0;</code>  改为 <code>Integer n = 0; </code> 也是正确的。</p><h1 id="3-hashCode"><a href="#3-hashCode" class="headerlink" title="3. hashCode"></a>3. hashCode</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><p><code>hashCode</code> 方法的作用是返回本对象的哈希码值。支持此方法是为了哈希表更好实现，例如 <code>java.util.HashMap</code> 提供的哈希表。<br><code>hashCode</code> 的一般约定是：</p><ul><li>程序运行期间多次调用同一个对象的 <code>hashCode</code> ，那么必须返回相同的整数，前提是在对象的 <code>equals</code> 比较中使用的信息没有被修改。如果启动两次程序，返回不需要保持一致。</li><li>如果 <code>equals()</code> 方法两个对象相等，则对这两个对象中的任一个调用 <code>hashCode</code> 方法返回值一致。</li><li>如果 <code>equals()</code> 方法两个对象不相等，不要求 <code>hashCode</code>方法都必须产生不同的结果。但是，程序员应该知道，为不相等的对象生成不同的整数结果可能会提高哈希表的性能。</li></ul><p>在普通情况下，<code>Object</code> 定义的 <code>hashCode</code> 方法确实会为不同的对象返回不同的整数。</p><h1 id="4-equals"><a href="#4-equals" class="headerlink" title="4. equals"></a>4. equals</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span> &#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">this</span> == obj);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>equals</code> 方法是经常会用到的方法了，用来判断某个其他对象是否 <strong>等于</strong> 这个对象，方法入参是需要对比的另一个对象。<br><code>equals</code> 方法在非空对象引用上实现有几个特性：</p><ul><li>自反性：对于任何非空引用值 <code>x</code> ， <code>x.equals(x)</code> 应该返回 <code>true</code> 。</li><li>对称性：对于任何非空引用值 <code>x</code> 和 <code>y</code> ，若 <code>x.equals(y)</code> 返回 <code>true</code> ，则 <code>y.equals(x)</code> 也返回 <code>true</code> 。</li><li>可传递性：对于任何非空引用值 <code>x</code> 、 <code>y</code> 和 <code>z</code> ，如果 <code>x.equals(y)</code> 返回 <code>true</code> 并且 <code>y.equals(z)</code> 返回 <code>true</code> ，那么 <code>x.equals(z)</code> 也应该返回true 。</li><li>一致性：对于任何非空引用值 <code>x</code> 和 <code>y</code> ，多次调用 <code>x.equals(y)</code> 始终返回 <code>true</code> 或始终返回 <code>false</code> ，前提是在对象的 <code>equals</code> 比较中使用的信息没有被修改。</li><li>对于任何非空引用值 <code>x</code>  ， <code>x.equals(null)</code> 应该返回 <code>false</code> 。</li></ul><p><code>Object</code> 的 <code>equals</code> 方法实现方式直接判断两个对象的内存地址是否一致。<br>通常需要在重写此方法时重写 <code>hashCode</code> 方法，以维护 <code>hashCode</code> 方法的一般约定。</p><h1 id="5-clone"><a href="#5-clone" class="headerlink" title="5. clone"></a>5. clone</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException;<br></code></pre></td></tr></table></figure><p><code>clone</code> 方法创建并返回此对象的副本。</p><p>此方法访问属性是 <code>protected</code> 的，只有子类和同包类可以 访问，而 <code>Object</code> 类又是 <code>java.lang</code> 包下的，所以一般来说 <code>Object</code> 类的 <code>clone</code> 方法是没办法直接调用的，都是通过子类去调用。如果该对象的类没有实现 <code>Cloneable</code> 接口，则会抛出 <code>CloneNotSupportedException</code> ，由于 <code>Object</code> 并没有实现 <code>Cloneable</code> 接口，所以即使调用了 <code>Object</code> 的 <code>clone</code> 方法也会抛出异常。</p><p>所有数组都被视为实现接口 <code>Cloneable</code> ，并且数组类型 <code>T []</code> 的clone方法的返回类型是 <code>T [] </code> ，其中 <code>T</code> 是任何引用或原始类型。</p><p>注意，此方法 <strong>默认是浅拷贝</strong>。</p><h1 id="6-toString"><a href="#6-toString" class="headerlink" title="6. toString"></a>6. toString</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> getClass().getName() + <span class="hljs-string">&quot;@&quot;</span> + Integer.toHexString(hashCode());<br>&#125;<br></code></pre></td></tr></table></figure><p><code>toString</code> 用来返回对象的字符串表示形式。通常， <code>toString</code> 方法返回一个 <em>文本表示</em> 此对象的字符串。结果应该是简洁但信息丰富的表示形式，易于人们阅读。建议所有子类重写此方法。<br><code>Object</code> 类的 <code>toString</code> 方法返回一个字符串，该字符串由全类名(包名+类名)、 <em>@</em> 和哈希的无符号十六进制形式组成。</p><p>普通自定义类的输出像下面这样：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-keyword">com</span>.cetuer.Demo<span class="hljs-subst">@74</span>a14482<br></code></pre></td></tr></table></figure><p>但是如果是数组，输出将会有很大区别。</p><p>对象数组像这样：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">[Ljava.lang.String<span class="hljs-comment">;@1540e19d</span><br></code></pre></td></tr></table></figure><p>基础类型数组像这样：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[I<span class="hljs-symbol">@677327b6</span><br></code></pre></td></tr></table></figure><p>二维数组像这样：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[[I<span class="hljs-symbol">@677327b6</span><br></code></pre></td></tr></table></figure><p>实际上，数组的全类名是比较特殊的，首先由 <code>[</code> 来表明这是个数组形式，几个 <code>[</code> 就代表着是几维数组，后面紧跟着的一个字母代表这个数组的类型，可能是：L（对象类型）、Z（boolean类型）、B（对象类型）、S（boolean类型）、C（对象类型）、I（boolean类型）、J（对象类型）、F（boolean类型）、D（对象类型）。如果是对象类型的话，紧跟着的是全类名加一个分号。</p><h1 id="7-notify与wait"><a href="#7-notify与wait" class="headerlink" title="7. notify与wait"></a>7. notify与wait</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 随机唤醒持有相同锁的单个线程</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">()</span>;<br><span class="hljs-comment">// 唤醒所有线程</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyAll</span><span class="hljs-params">()</span>;<br><span class="hljs-comment">// 使当前线程等待timeout秒后自动唤醒</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br><span class="hljs-comment">// 使当前线程等待</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    wait(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-comment">// 等待时间加额外等待时间，取近似值</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, <span class="hljs-type">int</span> nanos)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">if</span> (timeout &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;timeout value is negative&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (nanos &lt; <span class="hljs-number">0</span> || nanos &gt; <span class="hljs-number">999999</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<br>            <span class="hljs-string">&quot;nanosecond timeout value out of range&quot;</span>);<br>    &#125;<br><span class="hljs-comment">// 额外等待时间大于0就近似的加1毫秒</span><br>    <span class="hljs-keyword">if</span> (nanos &gt; <span class="hljs-number">0</span>) &#123;<br>        timeout++;<br>    &#125;<br><br>    wait(timeout);<br>&#125;<br></code></pre></td></tr></table></figure><p>在解读之前先放一张线程状态图：</p><p><img src="/posts/17071/716271-20170320112245721-1831918220.jpg" alt="线程状态图"></p><ul><li><p><strong>wait(long timeout)<strong>：从</strong>调用处</strong>使当前线程在对象的监视器上等待，直到另一个线程为此对象调用 <code>notify()</code> 方法或 <code>notifyAll()</code> 方法来唤醒此线程，或者经过 <code>timeout</code> 时间后自动唤醒，若 <code>timeout</code> 为0则只能通过其它线程唤醒，若被中断则抛出 <code>InterruptedException</code> 异常。</p><p>从线程状态图中可以看到调用 <code>wait</code> 后线程状态从运行状态变为了等待状态。</p></li><li><p><strong>wait()</strong> ：<code>wait</code> 的重载，传递 <code>timeout</code> 为 0，不会超时自动唤醒。</p></li><li><p>**wait(long timeout, int nanos)**：<code>wait</code> 的重载，多传递了一个纳秒，从源码看如果传递了纳秒则超时时间加一毫秒，并且做了一些数值合法验证。</p></li><li><p>**notify()**：唤醒在此对象监视器上等待的单个线程。如果有多个线程正在等待该对象，则随机选择唤醒其中一个线程。</p><p>从线程状态图中可以看到调用 <code>notify</code> 后线程状态从等待状态变为了锁定状态，在拿到同步锁并且被调度后便又重新变为执行状态了。</p></li><li><p>**notifyAll()**：唤醒在此对象的监视器上等待的所有线程。</p></li></ul><h1 id="8-finalize"><a href="#8-finalize" class="headerlink" title="8. finalize"></a>8. finalize</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123; &#125;<br></code></pre></td></tr></table></figure><p>当垃圾收集器回收此对象前会执行 <code>finalize</code> 方法。子类重写 <code>finalize</code> 方法以处理系统资源或执行其他清理。<code>Java</code> 虚拟机永远不会多次调用 <code>finalize</code> 方法。</p><p>简单来说其实就是在执行 <code>gc</code> 前调用的一个方法，但是不保证里面的方法会被执行完。</p>]]></content>
    
    
    <categories>
      
      <category>源码分析</category>
      
      <category>JDK源码</category>
      
      <category>基础类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>源码分析</tag>
      
      <tag>JDK源码</tag>
      
      <tag>基础类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CAP原则与BASE理论</title>
    <link href="/posts/24660.html"/>
    <url>/posts/24660.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-CAP原则"><a href="#1-CAP原则" class="headerlink" title="1. CAP原则"></a>1. CAP原则</h1><p>CAP原则又被称为CAP定理，指的是在一个分布式系统中，<strong>一致性（Consistency）</strong>、<strong>可用性（Availability）</strong>、<strong>分区容错性（Partition tolerance）</strong>三要素最多只能同时实现两点，不可能三者兼顾。</p><p><img src="/posts/24660/image-20221218184406197.png" alt="CAP三要素"></p><h2 id="1-1-一致性"><a href="#1-1-一致性" class="headerlink" title="1.1 一致性"></a>1.1 一致性</h2><p>用户在同一时刻访问分布式系统中的任意节点，得到的数据必须一致。</p><p>比如现在包含两个节点，初始数据皆为v0，此时用户向G1节点写入数据v1。</p><p><img src="/posts/24660/bg2018071602.png"></p><p>接下来，用户向G1发起读操作就会得到v1，这是一致性。</p><p><img src="/posts/24660/bg2018071603.png"></p><p>但是，如果用户向G2发起读操作，由于G2的值没有发生变化，返回的值是v0。G1和G2的读结果不一致，那么这个分布式系统就不满足一致性了。</p><p><img src="/posts/24660/bg2018071604.png"></p><p>为了能使此系统满足一致性，那么就要在G1在写操作的时候，向G2发送一条消息，将G2的数据也改为v1。</p><p><img src="/posts/24660/bg2018071605.png"></p><p>此时用户向G2发起读操作和G1获取的数据一致。</p><p><img src="/posts/24660/bg2018071606.png"></p><p>值得注意的是，此分布式系统此时仍不满足一致性，要想满足一致性，在G2进行写操作时也要向G1发送同步数据消息。</p><h2 id="1-2-可用性"><a href="#1-2-可用性" class="headerlink" title="1.2 可用性"></a>1.2 可用性</h2><p>用户访问分布式系统中的任意健康节点，不管成功或者失败都必须能得到响应，而不是超时或拒绝。</p><p>用户向G1或者G2发起操作时，不管是哪个节点都必须在 <strong>一定的时间</strong> 内 <strong>返回结果</strong>，否则不满足可用性。</p><h2 id="1-3-分区容错性"><a href="#1-3-分区容错性" class="headerlink" title="1.3 分区容错性"></a>1.3 分区容错性</h2><p><strong>分区</strong>：因为网络故障或其它原因导致分布式系统中的部分节点与其它节点失去连接，形成独立分区。</p><p><img src="/posts/24660/bg2018071601.png"></p><p>比如，G1节点在中国，G2节点在美国，这样G1和G2就是两个区，G1 向 G2 发送一条消息，G2 可能无法收到。</p><p><strong>容错</strong>：在出现分区时，整个系统也要持续对外提供服务。</p><p>一般来说，分区容错无法避免，系统设计的时候，必须考虑到这种情况。</p><h2 id="1-4-一致性与可用性的矛盾"><a href="#1-4-一致性与可用性的矛盾" class="headerlink" title="1.4 一致性与可用性的矛盾"></a>1.4 一致性与可用性的矛盾</h2><p>在分布式系统中无法百分百保证网络健康，那么分区容错不可避免，那么问题就出现了。</p><p>如果保证一致性，那么G1在写操作时就必须锁定G2的读写请求，只有数据同步之后才会重新开放G2的读写。那么锁定期间整个系统就没有可用性。</p><p>如果保证可用性，那么G2的数据可能会和G1不一致，那么就无法保证一致性。</p><p>因为 <code>A</code> 与 <code>C</code> 有矛盾，而 <code>CAP原则</code> 又指出了三元素最多只能两者共存，那么就诞生了两种系统，<code>AP</code> 与 <code>CP</code> ，AP 为高可用系统，而CP为高一致性系统。</p><h2 id="1-5-常用的框架所属分布式系统"><a href="#1-5-常用的框架所属分布式系统" class="headerlink" title="1.5 常用的框架所属分布式系统"></a>1.5 常用的框架所属分布式系统</h2><table><thead><tr><th align="center"></th><th align="center">AP</th><th align="center">CP</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">Eureka</td><td align="center">✓</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">Zookeeper</td><td align="center"></td><td align="center">✓</td><td align="center"></td></tr><tr><td align="center">Nacos</td><td align="center">✓</td><td align="center">✓</td><td align="center">默认AP，可调整为CP</td></tr><tr><td align="center">Consul</td><td align="center"></td><td align="center">✓</td><td align="center"></td></tr><tr><td align="center">Redis集群</td><td align="center">✓</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">ES集群</td><td align="center"></td><td align="center">✓</td><td align="center">集群出现分区，数据分片时集群不可用</td></tr></tbody></table><h1 id="2-BASE理论"><a href="#2-BASE理论" class="headerlink" title="2. BASE理论"></a>2. BASE理论</h1><p>BASE理论是对CAP的一种解决思路，是三要素的缩写：</p><ul><li><strong>Basically Available</strong> <strong>（基本可用）</strong>：分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。相比于正常的系统，可能是响应时间延长，或者是服务被降级。</li><li><strong>Soft State（软状态）：</strong>在一定时间内，允许出现中间状态，即允许系统在不同节点的数据副本上存在数据延时。</li><li><strong>Eventually Consistent（最终一致性）</strong>： 数据不可能一直处于软状态，必须在一个时间期限后达到各个节点的一致性。在期限过后，应当保证所有副本中的数据保持一致性，也就是达到了数据的最终一致性。</li></ul>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
      <category>理论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CAP原则</tag>
      
      <tag>BASE理论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ高可用</title>
    <link href="/posts/21417.html"/>
    <url>/posts/21417.html</url>
    
    <content type="html"><![CDATA[<p>想要高可用，那必要搭建集群，<code>RabbitMQ</code> 基于 <code>Erlang</code> 语言编写，而 <code>Erlang</code> 又是一个面向并发的语言，天然支持集群模式。<code>Rabbit MQ</code> 集群有两种模式：</p><ul><li><strong>普通集群</strong>：即分布式集群，将队列分散到集群的各个节点，从而提升并发能力。</li><li><strong>镜像集群</strong>：即主从集群，在普通集群的基础上，添加了主从备份功能，提高数据的可用性。</li></ul><p>镜像集群虽然支持主从，但是数据却不是强一致的，可能会出现数据丢失风险，为了解决这一问题， <code>Rabbit MQ</code> 在 3.8 版本引入了 <strong>仲裁队列</strong> 来代替镜像集群，采用 <code>Raft</code> 协议保证主从数据的一致性。</p><h1 id="1-普通集群"><a href="#1-普通集群" class="headerlink" title="1. 普通集群"></a>1. 普通集群</h1><p> 普通集群具备以下特征：</p><ul><li>会在集群的各个节点共享部分数据，包括交换机、队列元信息，不会共享队列中的消息。</li><li>当访问集群某节点时，若队列不在该节点，那么该节点会请求队列真正所在节点获取数据并返回。</li><li>队列所在节点宕机则队列消息丢失。</li></ul><p>具体如下图所示</p><p><img src="/posts/21417/image-20221127185736361.png" alt="普通集群获取消息"></p><p>接下来将搭建普通集群。</p><h2 id="1-1-部署计划"><a href="#1-1-部署计划" class="headerlink" title="1.1 部署计划"></a>1.1 部署计划</h2><p>计划部署三个<code>mq</code> 节点，组成一个集群，详细部署计划如下表：</p><table><thead><tr><th align="center">主机名称</th><th align="center">控制台端口号</th><th align="center">amqp通信端口</th><th align="center">节点标识</th></tr></thead><tbody><tr><td align="center">mq1</td><td align="center">8081 -&gt; 15672</td><td align="center">8071 -&gt; 5672</td><td align="center">rabbit@mq1</td></tr><tr><td align="center">mq2</td><td align="center">8082 -&gt; 15672</td><td align="center">8072 -&gt; 5672</td><td align="center">rabbit@mq2</td></tr><tr><td align="center">mq3</td><td align="center">8083 -&gt; 15672</td><td align="center">8073 -&gt; 5672</td><td align="center">rabbit@mq3</td></tr></tbody></table><p>集群中默认节点标识是：<code>rabbit@[hostname]</code>。</p><h2 id="1-2-准备配置"><a href="#1-2-准备配置" class="headerlink" title="1.2 准备配置"></a>1.2 准备配置</h2><h3 id="1-2-1-准备cookie"><a href="#1-2-1-准备cookie" class="headerlink" title="1.2.1 准备cookie"></a>1.2.1 准备cookie</h3><p>要使节点能够互相通信，则他们必须 **具有相同的 <code>cookie</code>  **， <code>cookie</code> 是一串最多 255 个字母数字组成的字符。</p><p>我们可以在之前启动过的 <code>mq</code> 中获取一个 <code>cookie</code> 来用做集群的 <code>cookie</code> ，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec -it mq cat /var/lib/rabbitmq/.erlang.cookie<br></code></pre></td></tr></table></figure><p>可以看到输出值如下：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">BVLXYJGLBETAPEAEIXNE</span><br></code></pre></td></tr></table></figure><p>然后在 <code>/tmp</code> 目录下新建一个名为 <code>.erlang.cookie</code> 的文件来记录 <code>cookie</code> ，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /tmp<br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建文件</span><br>touch .erlang.cookie<br><span class="hljs-meta prompt_"># </span><span class="language-bash">写入cookie到文件中</span><br>echo &quot;BVLXYJGLBETAPEAEIXNE&quot; &gt; .erlang.cookie<br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改文件权限</span><br>chmod 600 .erlang.cookie<br></code></pre></td></tr></table></figure><h3 id="1-2-2-准备配置文件"><a href="#1-2-2-准备配置文件" class="headerlink" title="1.2.2 准备配置文件"></a>1.2.2 准备配置文件</h3><p>在 <code>/tmp</code> 路径下新建一个配置文件 <code>rabbitmq.cong</code> ：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /tmp<br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建文件</span><br>touch rabbitmq.conf<br></code></pre></td></tr></table></figure><p>将以下内容写入到文件中：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 配置官网：https://www.rabbitmq.com/configure.html</span><br><span class="hljs-comment"># 取消只可在本机访问guset用户的限制</span><br>loopback_users.<span class="hljs-attribute">guest</span> = <span class="hljs-literal">false</span><br><span class="hljs-comment"># 指定客户端通信端口</span><br>listeners.tcp.default = <span class="hljs-number">5672</span><br><span class="hljs-comment"># 集群节点发现配置</span><br>cluster_formation.peer_discovery_backend = classic_config<br><span class="hljs-comment"># 集群节点1</span><br>cluster_formation.classic_config.nodes.<span class="hljs-number">1</span> = rabbit<span class="hljs-variable">@mq1</span><br><span class="hljs-comment"># 集群节点2</span><br>cluster_formation.classic_config.nodes.<span class="hljs-number">2</span> = rabbit<span class="hljs-variable">@mq2</span><br><span class="hljs-comment"># 集群节点3</span><br>cluster_formation.classic_config.nodes.<span class="hljs-number">3</span> = rabbit<span class="hljs-variable">@mq3</span><br></code></pre></td></tr></table></figure><p>然后再新建三个文件夹，mq1、mq2、mq3，将 <code>rabbitmq.conf</code> 和 <code>.erlang.cookie</code> 文件分别拷贝到三个目录中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">进入/tmp</span><br>cd /tmp<br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建目录</span><br>mkdir mq1 mq2 mq3<br><span class="hljs-meta prompt_"># </span><span class="language-bash">拷贝</span><br>cp rabbitmq.conf mq1<br>cp rabbitmq.conf mq2<br>cp rabbitmq.conf mq3<br>cp .erlang.cookie mq1<br>cp .erlang.cookie mq2<br>cp .erlang.cookie mq3<br></code></pre></td></tr></table></figure><h3 id="1-2-3-启动集群"><a href="#1-2-3-启动集群" class="headerlink" title="1.2.3 启动集群"></a>1.2.3 启动集群</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建一个网络</span><br>docker network create mq-net<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建并启动第一个mq</span><br>docker run -d --net mq-net \<br>-v /tmp/mq1/rabbitmq.conf:/etc/rabbitmq/rabbitmq.conf \<br>-v /tmp/mq1/.erlang.cookie:/var/lib/rabbitmq/.erlang.cookie \<br>-e RABBITMQ_DEFAULT_USER=cetuer \<br>-e RABBITMQ_DEFAULT_PASS=cetuer \<br>--name mq1 \<br>--hostname mq1 \<br>-p 8071:5672 \<br>-p 8081:15672 \<br>rabbitmq:latest<br><span class="hljs-meta prompt_"># </span><span class="language-bash">进入容器</span><br>docker exec -it mq1 /bin/bash<br><span class="hljs-meta prompt_"># </span><span class="language-bash">启用web界面插件</span><br>rabbitmq-plugins enable rabbitmq_management<br><span class="hljs-meta prompt_"># </span><span class="language-bash">启用统计信息和指标收集</span><br>echo management_agent.disable_metrics_collector = false &gt; /etc/rabbitmq/conf.d/management_agent.disable_metrics_collector.conf<br><span class="hljs-meta prompt_"># </span><span class="language-bash">退出容器</span><br>exit<br><span class="hljs-meta prompt_"># </span><span class="language-bash">重启容器</span><br>docker restart mq1<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建并启动第二个mq</span><br>docker run -d --net mq-net \<br>-v /tmp/mq2/rabbitmq.conf:/etc/rabbitmq/rabbitmq.conf \<br>-v /tmp/mq2/.erlang.cookie:/var/lib/rabbitmq/.erlang.cookie \<br>-e RABBITMQ_DEFAULT_USER=cetuer \<br>-e RABBITMQ_DEFAULT_PASS=cetuer \<br>--name mq2 \<br>--hostname mq2 \<br>-p 8072:5672 \<br>-p 8082:15672 \<br>rabbitmq:latest<br><span class="hljs-meta prompt_"># </span><span class="language-bash">进入容器</span><br>docker exec -it mq2 /bin/bash<br><span class="hljs-meta prompt_"># </span><span class="language-bash">启用web界面插件</span><br>rabbitmq-plugins enable rabbitmq_management<br><span class="hljs-meta prompt_"># </span><span class="language-bash">启用统计信息和指标收集</span><br>echo management_agent.disable_metrics_collector = false &gt; /etc/rabbitmq/conf.d/management_agent.disable_metrics_collector.conf<br><span class="hljs-meta prompt_"># </span><span class="language-bash">退出容器</span><br>exit<br><span class="hljs-meta prompt_"># </span><span class="language-bash">重启容器</span><br>docker restart mq2<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建并启动第三个mq</span><br>docker run -d --net mq-net \<br>-v /tmp/mq3/rabbitmq.conf:/etc/rabbitmq/rabbitmq.conf \<br>-v /tmp/mq3/.erlang.cookie:/var/lib/rabbitmq/.erlang.cookie \<br>-e RABBITMQ_DEFAULT_USER=cetuer \<br>-e RABBITMQ_DEFAULT_PASS=cetuer \<br>--name mq3 \<br>--hostname mq3 \<br>-p 8073:5672 \<br>-p 8083:15672 \<br>rabbitmq:latest<br><span class="hljs-meta prompt_"># </span><span class="language-bash">进入容器</span><br>docker exec -it mq3 /bin/bash<br><span class="hljs-meta prompt_"># </span><span class="language-bash">启用web界面插件</span><br>rabbitmq-plugins enable rabbitmq_management<br><span class="hljs-meta prompt_"># </span><span class="language-bash">启用统计信息和指标收集</span><br>echo management_agent.disable_metrics_collector = false &gt; /etc/rabbitmq/conf.d/management_agent.disable_metrics_collector.conf<br><span class="hljs-meta prompt_"># </span><span class="language-bash">退出容器</span><br>exit<br><span class="hljs-meta prompt_"># </span><span class="language-bash">重启容器</span><br>docker restart mq3<br></code></pre></td></tr></table></figure><p>打开 8081 端口发现三个节点均在线，说明集群启动成功。</p><p><img src="/posts/21417/image-20221128203535703.png" alt="节点状态"></p><h3 id="1-2-4-测试"><a href="#1-2-4-测试" class="headerlink" title="1.2.4 测试"></a>1.2.4 测试</h3><p>在 <code>mq1</code> 上新建一个 <code>simple.queue</code> 队列，然后发现在 <code>mq2</code> 和 <code>mq3</code> 上都能看到此队列，说明队列元信息是共享的。</p><p><img src="/posts/21417/image-20221128205305997.png" alt="mq1创建队列"></p><p><img src="/posts/21417/image-20221128205408264.png" alt="mq2查看队列"></p><p><img src="/posts/21417/image-20221128205440213.png" alt="mq3查看队列"></p><p>·在 <code>simple.queue</code> 中发送一条消息，发现其它节点也能看到这条消息。</p><p><img src="/posts/21417/image-20221128211202546.png" alt="mq1发送消息"></p><p><img src="/posts/21417/image-20221128211229402.png" alt="mq2查看消息"></p><p><img src="/posts/21417/image-20221128211247779.png" alt="mq3查看消息"></p><p>使 <code>mq1</code> 宕机，发现  <code>mq2</code> 和 <code>mq3</code> 的 <code>simple.queue</code> 队列不可用，证明消息没有拷贝。</p><p><img src="/posts/21417/image-20221128211845008.png" alt="mq2查看队列宕机"></p><h1 id="2-镜像集群"><a href="#2-镜像集群" class="headerlink" title="2. 镜像集群"></a>2. 镜像集群</h1><p>在普通集群中，一旦创建队列的主机宕机，队列就会不可用，因此普通集群只具备高并发能力，而镜像集群则具备高并发与高可用能力。</p><p>镜像集群具备以下特征：</p><ul><li>交换机、队列、消息会在各个 <code>mq</code> 的镜像节点中同步备份。</li><li>创建队列的节点被称为该队列的 <strong>主节点</strong> ，备份到的其它节点叫做该队列的 <strong>镜像节点</strong> 。通俗来说其实就是主从集群。</li><li>一个队列的主节点可能是其它队列的镜像节点。</li><li>所有操作都是主节点完成，然后同步给镜像节点，即使镜像节点接收到请求，也是转发给主节点处理。</li><li>主节点宕机后，镜像节点会成为新的主节点，并选择新的镜像节点。</li><li>主节点接收到消费者的 <code>ACK</code> 时，所有镜像节点都会删除数据。</li></ul><p>结构图如下：</p><p><img src="/posts/21417/image-20221128223518973.png" alt="镜像集群"></p><h2 id="2-1-镜像模式配置"><a href="#2-1-镜像模式配置" class="headerlink" title="2.1 镜像模式配置"></a>2.1 镜像模式配置</h2><table><thead><tr><th align="center">ha-mode</th><th align="center">ha-params</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">exactly</td><td align="center">副本数量</td><td align="center">指定集群中副本的数量，包括主节点，即：副本数量 &#x3D; 镜像数量 + 1。若包含镜像的节点故障，则在另一个节点上新建一个镜像。推荐副本数量设为（N &#x2F; 2 + 1），其中N为集群节点数量</td></tr><tr><td align="center">all</td><td align="center"></td><td align="center">在集群中所有节点上进行镜像</td></tr><tr><td align="center">nodes</td><td align="center">节点名称数组</td><td align="center">指定队列创建的节点，若指定节点全部不存在则出现异常。如果指定节点存在但不可用，则会创建到当前客户端连接到的节点</td></tr></tbody></table><p><strong>exactly模式</strong></p><p>使用 <code>rabbitmqctl</code> 执行以下命令来进行配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rabbitmqctl set_policy ha-two &quot;^two\.&quot; &#x27;&#123;&quot;ha-mode&quot;:&quot;exactly&quot;,&quot;ha-params&quot;:2,&quot;ha-sync-mode&quot;:&quot;automatic&quot;&#125;&#x27;<br></code></pre></td></tr></table></figure><ul><li><p><code>set_policy</code> ：设置策略</p></li><li><p><code>ha-two</code> ：策略名称，自定义</p></li><li><p><code>&quot;^two\.&quot;</code> ：匹配队列的正则表达式，符合命名规则的队列才生效，这里是任何以<code>two.</code>开头的队列名称</p></li><li><p><code>&#123;&quot;ha-mode&quot;:&quot;exactly&quot;,&quot;ha-params&quot;:2,&quot;ha-sync-mode&quot;:&quot;automatic&quot;&#125;</code> ：策略内容</p><ul><li><code>&quot;ha-mode&quot;:&quot;exactly&quot;</code> ： 指定模式为 <code>exactly</code></li><li><code>&quot;ha-params&quot;:2</code> ： 指定副本数量为2，即一个主节点，一个镜像节点</li><li><code>&quot;ha-sync-mode&quot;:&quot;automatic&quot;</code> ：同步策略，默认是manual，即新加入的镜像节点不会同步旧的消息。如果设置为automatic，则新加入的镜像节点会把主节点中所有消息都同步，会带来额外的网络开销</li></ul></li></ul><p><strong>all模式</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rabbitmqctl set_policy ha-all &quot;^all\.&quot; &#x27;&#123;&quot;ha-mode&quot;:&quot;all&quot;&#125;&#x27;<br></code></pre></td></tr></table></figure><p><strong>nodes模式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">rabbitmqctl set_policy ha-nodes <span class="hljs-string">&quot;^nodes\.&quot;</span> <span class="hljs-string">&#x27;&#123;&quot;ha-mode&quot;:&quot;nodes&quot;,&quot;ha-params&quot;:[&quot;rabbit@nodeA&quot;, &quot;rabbit@nodeB&quot;]&#125;&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="2-2-测试"><a href="#2-2-测试" class="headerlink" title="2.2 测试"></a>2.2 测试</h2><p>我们使用 <code>exactly</code> 模式，设置镜像数量为 2，并且将 <code>mq1</code> 设置为主节点。</p><p>运行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec -it mq1 rabbitmqctl set_policy ha-two &quot;^two\.&quot; &#x27;&#123;&quot;ha-mode&quot;:&quot;exactly&quot;,&quot;ha-params&quot;:2,&quot;ha-sync-mode&quot;:&quot;automatic&quot;&#125;&#x27;<br></code></pre></td></tr></table></figure><p>然后在 <code>mq1</code> 上新建一个以 <code>two.</code> 开头的队列</p><p><img src="/posts/21417/image-20221204231211504.png" alt="新增tow.开头队列"></p><p>新增完成后发现队列 <code>Node</code> 栏有个 <code>+1</code> ，鼠标放上去出现 <code>Synchronised mirrors: rabbit@mq3</code> ，说明镜像节点是 <code>mq3</code> 。</p><p><img src="/posts/21417/image-20221204231515906.png" alt="查看镜像节点"></p><p>此时，我们使 <code>mq1</code> 宕机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker stop mq1<br></code></pre></td></tr></table></figure><p>然后进入到 <code>mq2</code> 或者 <code>mq3</code> 的控制台页面，发现队列依然可用，并且镜像节点变为了 <code>mq2</code> 。</p><p><img src="/posts/21417/image-20221204232327230.png" alt="节点状态"></p><p><img src="/posts/21417/image-20221204232408026.png" alt="队列状态"></p><h1 id="3-仲裁队列"><a href="#3-仲裁队列" class="headerlink" title="3. 仲裁队列"></a>3. 仲裁队列</h1><p>仲裁队列是 <code>Rabbit MQ</code> 3.8 版本后才有的新功能，用以代替镜像集群，有以下特征：</p><ul><li>与镜像队列一样，都是主从模式，支持主从数据同步</li><li>使用非常简单，没有复杂的配置</li><li>主从同步基于Raft协议，强一致</li></ul><h2 id="3-1-创建仲裁队列"><a href="#3-1-创建仲裁队列" class="headerlink" title="3.1 创建仲裁队列"></a>3.1 创建仲裁队列</h2><p>在集群任意一个控制台创建队列，注意类型要选择 <code>Quorum</code> 类型。</p><p><img src="/posts/21417/image-20221205220249101.png" alt="创建仲裁队列"></p><p>点开队列详情即可发现主节点为 <code>mq1</code> ， 成员有 <code>mq2</code> 和 <code>mq3</code>。</p><p><img src="/posts/21417/image-20221205220533414.png" alt="仲裁队列详情"></p><p>因为仲裁队列默认的镜像数为5。如果你的集群有7个节点，那么镜像数肯定是5；而我们集群只有3个节点，因此镜像数量就是3。</p><h1 id="4-集群扩容"><a href="#4-集群扩容" class="headerlink" title="4. 集群扩容"></a>4. 集群扩容</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建并启动第四个mq</span><br>docker run -d --net mq-net \<br>-v /tmp/mq1/rabbitmq.conf:/etc/rabbitmq/rabbitmq.conf \<br>-v /tmp/mq1/.erlang.cookie:/var/lib/rabbitmq/.erlang.cookie \<br>-e RABBITMQ_DEFAULT_USER=cetuer \<br>-e RABBITMQ_DEFAULT_PASS=cetuer \<br>--name mq4 \<br>--hostname mq4 \<br>-p 8074:5672 \<br>-p 8084:15672 \<br>rabbitmq:latest<br><span class="hljs-meta prompt_"># </span><span class="language-bash">进入容器</span><br>docker exec -it mq4 bash<br><span class="hljs-meta prompt_"># </span><span class="language-bash">停止mq进程</span><br>rabbitmqctl stop_app<br><span class="hljs-meta prompt_">#</span><span class="language-bash">重置RabbitMQ中的数据</span><br>rabbitmqctl reset<br><span class="hljs-meta prompt_"># </span><span class="language-bash">加入mq1</span><br>rabbitmqctl join_cluster rabbit@mq1<br><span class="hljs-meta prompt_">#</span><span class="language-bash">再次启动mq进程</span><br>rabbitmqctl start_app<br></code></pre></td></tr></table></figure><p>然后同样的，启用 <code>web</code> 管理插件，及启用统计功能，同上文。</p><p>完成后打开任意一个 <code>mq</code> 的控制台可发现 <code>mq4</code> 已加入到集群中。</p><p><img src="/posts/21417/image-20221205221922921.png" alt="新增节点"></p><h1 id="5-仲裁队列增加副本"><a href="#5-仲裁队列增加副本" class="headerlink" title="5. 仲裁队列增加副本"></a>5. 仲裁队列增加副本</h1><p>如何让在已存在的仲裁队列上添加副本呢？</p><p>我们先查看下 <code>quorum.queue</code> 这个队列目前的副本情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">进入mq1容器</span><br>docker exec -it mq1 bash<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看仲裁队列状态</span><br>rabbitmq-queues quorum_status &quot;quorum.queue&quot;<br></code></pre></td></tr></table></figure><p><img src="/posts/21417/image-20221205222320060.png" alt="查看仲裁队列状态"></p><p>可以看到主节点是 <code>mq1</code> ，另外两个是从节点，接下来让 <code>mq4</code> 加入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rabbitmq-queues add_member &quot;quorum.queue&quot; &quot;rabbit@mq4&quot;<br></code></pre></td></tr></table></figure><p>然后再次查看状态发现已成功加入，且 <code>web</code> 界面显示也出现了 <code>mq4</code>。</p><p><img src="/posts/21417/image-20221205222603043.png" alt="再次查看状态"></p><p><img src="/posts/21417/image-20221205222628716.png" alt="web界面查看详情"></p>]]></content>
    
    
    <categories>
      
      <category>微服务学习</category>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RabbitMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ消息堆积问题</title>
    <link href="/posts/50782.html"/>
    <url>/posts/50782.html</url>
    
    <content type="html"><![CDATA[<p>消息堆积问题指的是当生产者发送消息的速度超过了消费者处理消息的速度，使得队列中的消息堆积，直到队列存储消息到达上限，之后发送的消息就会成为死信，可能会被丢弃。</p><p>解决消息堆积有以下几种思路：</p><ul><li>增加更多的消费者，提高消费速度。</li><li>消费者内部使用多线程处理消息，提高消费速度。</li><li>扩大队列容量，提高堆积上限。</li></ul><span id="more"></span><h1 id="惰性队列"><a href="#惰性队列" class="headerlink" title="惰性队列"></a>惰性队列</h1><p><code>Rabbit MQ</code> 从 <code>3.6.0</code> 版本开始增加了 <code>Lazy Queues</code> 的概念，也就是惰性队列，惰性队列的特性如下：</p><ul><li>惰性队列接收到消息后直接存入磁盘，而普通消息是先存到内存然后 <code>Page Out</code> 到硬磁盘。</li><li>消费者要消费消息时才会从磁盘中读取对应消息并加载到内存。</li><li>支持数百万条的消息存储。</li></ul><h2 id="1-基于命令行设置lazy-queue"><a href="#1-基于命令行设置lazy-queue" class="headerlink" title="1. 基于命令行设置lazy-queue"></a>1. 基于命令行设置lazy-queue</h2><p>通过命令行的方式可以使正在运行的队列设置为惰性队列，命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">进入容器</span><br>docker exec -it rabbitmq /bin/bash<br><span class="hljs-meta prompt_"># </span><span class="language-bash">rabbitmqctl：命令行工具；set_policy：添加一个策略；Lazy：策略名称，可以自定义；<span class="hljs-string">&quot;^test.queue$&quot;</span>：正则匹配队列名称；<span class="hljs-string">&#x27;&#123;&quot;queue-mode&quot;:&quot;lazy&quot;&#125;&#x27;</span>：设置队列模式为lazy；--apply-to queues：策略的作用对象，是所有队列</span><br>rabbitmqctl set_policy Lazy &quot;^test.queue$&quot; &#x27;&#123;&quot;queue-mode&quot;:&quot;lazy&quot;&#125;&#x27; --apply-to queues<br></code></pre></td></tr></table></figure><p>成功设置后，打开可视化界面，队列策略已经成功添加</p><p><img src="/posts/50782/image-20221120175430866.png" alt="命令行添加lazy"></p><p><img src="/posts/50782/image-20221120175520455.png" alt="策略详情"></p><h2 id="2-基于-RabbitListener声明lazy-queue"><a href="#2-基于-RabbitListener声明lazy-queue" class="headerlink" title="2. 基于@RabbitListener声明lazy-queue"></a>2. 基于@RabbitListener声明lazy-queue</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringRabbitListener</span> &#123;<br>    <span class="hljs-meta">@RabbitListener(queuesToDeclare = @Queue(</span><br><span class="hljs-meta">            name = &quot;lazy.queue&quot;,</span><br><span class="hljs-meta">            durable = &quot;true&quot;,</span><br><span class="hljs-meta">            arguments = @Argument(name = &quot;x-queue-mode&quot;, value = &quot;lazy&quot;)</span><br><span class="hljs-meta">    ))</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenLazyQueue</span><span class="hljs-params">(String msg)</span> &#123;<br>        System.out.println(LocalDateTime.now());<br>        System.out.println(<span class="hljs-string">&quot;lazy.queue接收到消息：&quot;</span> + msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-基于-Bean声明lazy-queue"><a href="#3-基于-Bean声明lazy-queue" class="headerlink" title="3. 基于@Bean声明lazy-queue"></a>3. 基于@Bean声明lazy-queue</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">lazyQueue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> QueueBuilder<br>        .durable(<span class="hljs-string">&quot;lazy.queue&quot;</span>)<br>        .lazy()<br>        .build();<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>微服务学习</category>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RabbitMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ的延迟消息问题</title>
    <link href="/posts/49141.html"/>
    <url>/posts/49141.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-死信交换机"><a href="#1-死信交换机" class="headerlink" title="1. 死信交换机"></a>1. 死信交换机</h1><p><strong>死信</strong>（ <code>dead letter</code> ）指的是无法被消费的信息。在 <code>Rabbit MQ</code> 中有以下情况会形成死信：</p><ul><li>消息被拒绝或者消费者返回 <code>nack</code> ，并且消息的 <code>requeue</code> 被设置为 <code>false</code> 。</li><li>消息队列满了，无法投递。</li><li>消息过期，超时无人消费。</li></ul><p>如果在队列中配置了 <code>dead-letter-exchange</code> 属性并指定了交换机的话，死信消息就会自动投递到这个交换机中，而这种交换机被称为 <strong>死信交换机</strong> （<code>Dead Letter Exchange</code> ，简称 <code>DLX</code>），死信交换机绑定的队列称为 <strong>死信队列</strong> （<code>Dead Letter Queue</code> ，简称 <code>DLQ</code>），最终消息会进入到死信队列中。</p> <span id="more"></span> <p>下面演示一下死信交换机</p><ol><li><p>配置文件（消费者）</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">listener:</span><br>      <span class="hljs-attr">simple:</span><br>        <span class="hljs-comment"># 自动ack</span><br>        <span class="hljs-attr">acknowledge-mode:</span> <span class="hljs-string">auto</span><br>        <span class="hljs-comment"># 失败后不重新入队</span><br>        <span class="hljs-attr">default-requeue-rejected:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure></li><li><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommonConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title function_">dlExchange</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DirectExchange</span>(<span class="hljs-string">&quot;dl.direct&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">dlQueue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>(<span class="hljs-string">&quot;dl.queue&quot;</span>, <span class="hljs-literal">true</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">dlBinding</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(dlQueue()).to(dlExchange()).with(<span class="hljs-string">&quot;dl&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title function_">simpleExchange</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DirectExchange</span>(<span class="hljs-string">&quot;simple.direct&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">simpleQueue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> QueueBuilder.durable(<span class="hljs-string">&quot;simple.queue&quot;</span>)<br>                <span class="hljs-comment">//声明死信交换机</span><br>                .deadLetterExchange(<span class="hljs-string">&quot;dl.direct&quot;</span>)<br>                <span class="hljs-comment">//声明死信路由</span><br>                .deadLetterRoutingKey(<span class="hljs-string">&quot;dl&quot;</span>).build();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">simpleBinding</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(simpleQueue()).to(simpleExchange()).with(<span class="hljs-string">&quot;simple&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试代码如这篇文章所示：<a href="/posts/24168.html" title="RabbitMQ的可靠性问题">RabbitMQ的可靠性问题</a></p><p>经测试，消息被拒绝后自动进入了死信队列中，如图</p><p><img src="/posts/49141/image-20221113194936316.png" alt="消息进入死信队列"></p></li></ol><h1 id="2-延迟消息"><a href="#2-延迟消息" class="headerlink" title="2. 延迟消息"></a>2. 延迟消息</h1><p>延迟消息就是指，消息发送后等待指定时间后被消费的消息。</p><p>实现延迟消息主要有两种方法：</p><ul><li><code>ttl</code> + 死信交换机。</li><li>使用 <code>DelayExchange</code> 插件。（ <code>RabbitMQ</code> <strong>3.8版本以上</strong> 才可使用）</li></ul><p><strong>使用TTL + 死信交换机实现延迟消息</strong></p><p>此方法实现延迟消息的原理是：给队列或者消息设置超时时间，而没有消费者去消费消息，这样这条消息就会自动投递到死信队列中，消费者去订阅死信队列即可实现延迟消息。</p><ol><li><p>消费者监听代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringRabbitListener</span> &#123;<br>    <span class="hljs-comment">// 监听死信队列</span><br>    <span class="hljs-meta">@RabbitListener(bindings = @QueueBinding(</span><br><span class="hljs-meta">            value = @Queue(&quot;dl.ttl.queue&quot;),</span><br><span class="hljs-meta">            exchange = @Exchange(&quot;dl.ttl.direct&quot;),</span><br><span class="hljs-meta">            key = &quot;ttl&quot;</span><br><span class="hljs-meta">    ))</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenDlQueue</span><span class="hljs-params">(String msg)</span> &#123;<br>        System.out.println(LocalDateTime.now());<br>        System.out.println(<span class="hljs-string">&quot;dl.ttl.queue接收到消息：&quot;</span> + msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>发送者配置代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommonConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">ttlQueue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> QueueBuilder<br>                .durable(<span class="hljs-string">&quot;ttl.queue&quot;</span>)<br>                <span class="hljs-comment">// 指定超时时间：10s</span><br>                .ttl(<span class="hljs-number">10000</span>)<br>                <span class="hljs-comment">// 指定死信交换机</span><br>                .deadLetterExchange(<span class="hljs-string">&quot;dl.ttl.direct&quot;</span>)<br>                .build();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title function_">ttlExchange</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DirectExchange</span>(<span class="hljs-string">&quot;ttl.direct&quot;</span>);<br>    &#125;<br>   <br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">ttlBinding</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(ttlQueue()).to(ttlExchange()).with(<span class="hljs-string">&quot;ttl&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>发送者测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testTTLQueue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello, ttl queue&quot;</span>;<br>    <span class="hljs-comment">// 发送消息</span><br>    rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;ttl.direct&quot;</span>, <span class="hljs-string">&quot;ttl&quot;</span>, message);<br>    System.out.println(LocalDateTime.now());<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>​这样便可以通过死信队列和超时机制实现延迟消息效果，值得一提的是，不但可以通过给队列设置超时时间，而且可以给消息设置超时时间，若同时设置，则以较短的那个为准。</p><p>​使用此方式实现的延迟队列有一个缺点，因为是队列，遵循先进先出的规则，队列只会检查队头的消息是否过期这样就会阻塞住队列，只有当队头消息过期后，才会检查下一个消息，这样就导致无法实现同一队列中多种超时时间。</p><p><strong>DelayExchange 插件实现延迟消息</strong></p><p><code>DelayExchange</code> 插件安装完毕后，<code>RabbitMQ</code> 会多出一种类型为 <code>delayed</code> 的交换机，当我们发送消息到这种类型的交换机中时，会做这些事：</p><ol><li>接收消息</li><li>判断消息是否有 <code>x-delay</code> 属性</li><li>如果有 <code>x-delay</code> 属性，说明是延迟消息，持久化到硬盘，读取 <code>x-delay</code> 值，作为延迟时间</li><li>返回 <code>routing not found</code> 结果给消息发送者</li><li><code>x-delay</code> 时间到期后，重新投递消息到指定队列</li></ol><p>从流程中可以看出， <code>delayed</code>  类型交换机是会触发发送者确认机制，且会报错的，在业务代码中我们需要判断 <code>header</code> 是否包含 <code>x-delay</code> 来避免处理这种情况。</p><ol><li><p><code>docker</code> 安装 <code>rabbitmq_delayed_message_exchange</code>  插件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">下载插件</span><br>wget https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases/download/3.9.0/rabbitmq_delayed_message_exchange-3.9.0.ez<br><span class="hljs-meta prompt_"># </span><span class="language-bash">拷贝插件到RabbitMQ容器内部</span><br>docker cp rabbitmq_delayed_message_exchange-3.9.0.ez rabbitmq:/plugins<br><span class="hljs-meta prompt_"># </span><span class="language-bash">进入容器</span><br>docker exec -it rabbitmq /bin/bash<br><span class="hljs-meta prompt_"># </span><span class="language-bash">启用插件</span><br>rabbitmq-plugins enable rabbitmq_delayed_message_exchange<br></code></pre></td></tr></table></figure></li></ol><p>​可视化界面添加交换机选项多出一个 <code>x-delayed-message</code> 选项即为安装成功。</p><p>​<img src="/posts/49141/image-20221119185011366.png" alt="安装插件成功"></p><ol start="2"><li><p>消费者配置类代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringRabbitListener</span> &#123;<br>    <span class="hljs-meta">@RabbitListener(bindings = @QueueBinding(</span><br><span class="hljs-meta">            value = @Queue(&quot;dl.delay.queue&quot;),</span><br><span class="hljs-meta">            // delayed = &quot;true&quot; 指定交换机为延迟交换机</span><br><span class="hljs-meta">            exchange = @Exchange(value = &quot;dl.delay.direct&quot;, delayed = &quot;true&quot;),</span><br><span class="hljs-meta">            key = &quot;delay&quot;</span><br><span class="hljs-meta">    ))</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenDelayQueue</span><span class="hljs-params">(String msg)</span> &#123;<br>        System.out.println(LocalDateTime.now());<br>        System.out.println(<span class="hljs-string">&quot;dl.delay.queue接收到消息：&quot;</span> + msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>生产者测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testDelayMsg</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello, delay message&quot;</span>;<br>    <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> MessageBuilder.withBody(message.getBytes(StandardCharsets.UTF_8))<br>        <span class="hljs-comment">// 指定延迟时间</span><br>        .setHeader(<span class="hljs-string">&quot;x-delay&quot;</span>, <span class="hljs-number">10000</span>)<br>        .build();<br>    <span class="hljs-comment">// 发送消息</span><br>    rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;dl.delay.direct&quot;</span>, <span class="hljs-string">&quot;delay&quot;</span>, msg);<br>    System.out.println(LocalDateTime.now());<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>运行结果</p><p>生产者</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2022</span>-<span class="hljs-number">11</span>-<span class="hljs-number">19</span>T20:<span class="hljs-number">05</span>:<span class="hljs-number">07</span>.<span class="hljs-number">480</span><br><span class="hljs-attribute">20</span>:<span class="hljs-number">05</span>:<span class="hljs-number">07</span>:<span class="hljs-number">719</span>  INFO <span class="hljs-number">4912</span> ---<span class="hljs-meta"> [nectionFactory1] cn.itcast.mq.config.CommonConfig         : 消息发送失败,应答码312,原因NO_ROUTE,交换机dl.delay.direct,路由键delay,消息hello, delay message</span><br></code></pre></td></tr></table></figure><p>消费者</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">2022</span>-<span class="hljs-number">11</span>-<span class="hljs-number">19</span>T20:<span class="hljs-number">05</span>:<span class="hljs-number">17</span>.<span class="hljs-number">615</span><br><span class="hljs-attribute">dl</span>.delay.queue接收到消息：hello, delay message<br></code></pre></td></tr></table></figure><p>从结果可以看出，成功延迟10秒接收到了消息，而且触发了发送者确认机制，这个原理分析时就已经提到过了。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>微服务学习</category>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RabbitMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ的可靠性问题</title>
    <link href="/posts/24168.html"/>
    <url>/posts/24168.html</url>
    
    <content type="html"><![CDATA[<p>消息可靠性问题指的是，如何保证消息至少被消费一次。</p><p>消息的发送流程如下图：</p><p><img src="/posts/24168/%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81%E6%B5%81%E7%A8%8B.png" alt="消息发送流程"></p><p>其中每一步都可能会导致消息的丢失，包括如下可能：</p><ul><li>生产者消息未推送到交换机</li><li>交换机消息未路由到队列</li><li>队列消息丢失</li><li>消费者接收到消息后未消费</li></ul><p>接下来按照顺序挨个解决这些可能丢失消息的问题。</p><span id="more"></span><h2 id="1-生产者消息未推送到交换机"><a href="#1-生产者消息未推送到交换机" class="headerlink" title="1. 生产者消息未推送到交换机"></a>1. 生产者消息未推送到交换机</h2><p><code>RabbitMQ</code> 提供了发送方确认机制 <code>Publisher Confirms</code> 来解决这个问题，原理是在消息发送后通过同步或者异步的方式告诉发送方此消息是否成功送达。</p><p><strong>同步方式</strong></p><ol><li><p>配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-comment"># 同步调用</span><br>    <span class="hljs-attr">publisher-confirm-type:</span> <span class="hljs-string">simple</span><br></code></pre></td></tr></table></figure></li><li><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSendMessage2ExchangeSync</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">routingKey</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;simple&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello, spring amqp!&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">exchange</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;camq.topic&quot;</span>;<br>    log.info(<span class="hljs-string">&quot;=======发送开始=======&quot;</span>);<br>    <span class="hljs-type">Boolean</span> <span class="hljs-variable">sendFlag</span> <span class="hljs-operator">=</span> rabbitTemplate.invoke( operations -&gt; &#123;<br>        operations.convertAndSend(exchange, routingKey, message);<br>        <span class="hljs-keyword">try</span> &#123;<br>            log.info(<span class="hljs-string">&quot;阻塞中...&quot;</span>);<br>            <span class="hljs-keyword">return</span> operations.waitForConfirms(<span class="hljs-number">10000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;);<br>    log.info(<span class="hljs-string">&quot;是否成功 -&gt; &#123;&#125;&quot;</span>, sendFlag);<br>    log.info(<span class="hljs-string">&quot;=======发送结束=======&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>测试结果</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros">00:41:37:341  <span class="hljs-built_in">INFO</span> 2868 --- [           main] cn.itcast.mq.spring.SpringAmqpTest       : =======发送开始=======<br>00:41:37:342  <span class="hljs-built_in">INFO</span> 2868 --- [           main] o.s.a.r.c.CachingConnectionFactory       : Attempting <span class="hljs-keyword">to</span> connect <span class="hljs-keyword">to</span>: [192.168.6.6:5672]<br>00:41:37:439  <span class="hljs-built_in">INFO</span> 2868 --- [           main] o.s.a.r.c.CachingConnectionFactory       : Created new connection: rabbitConnectionFactory#61a5b4ae:0/SimpleConnection@3c0036b [<span class="hljs-attribute">delegate</span>=amqp://cetuer@192.168.6.6:5672/, localPort= 60905]<br>00:41:37:489  <span class="hljs-built_in">INFO</span> 2868 --- [           main] cn.itcast.mq.spring.SpringAmqpTest       : 阻塞中<span class="hljs-built_in">..</span>.<br>00:41:37:530 <span class="hljs-built_in">ERROR</span> 2868 --- [92.168.6.6:5672] o.s.a.r.c.CachingConnectionFactory       : Channel shutdown: channel error; protocol method: #method&lt;channel.close&gt;(<span class="hljs-attribute">reply-code</span>=404, <span class="hljs-attribute">reply-text</span>=NOT_FOUND - <span class="hljs-literal">no</span> exchange <span class="hljs-string">&#x27;camq.topic&#x27;</span> <span class="hljs-keyword">in</span> vhost <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-attribute">class-id</span>=60, <span class="hljs-attribute">method-id</span>=40)<br>00:41:37:539  <span class="hljs-built_in">INFO</span> 2868 --- [           main] cn.itcast.mq.spring.SpringAmqpTest       : 是否成功 -&gt; <span class="hljs-literal">false</span><br>00:41:37:540  <span class="hljs-built_in">INFO</span> 2868 --- [           main] cn.itcast.mq.spring.SpringAmqpTest       : =======发送结束=======<br></code></pre></td></tr></table></figure></li><li><p>分析</p><p>注意，同步方式需要调用 <strong><code>invoke</code></strong> 方法，在方法回调内部发送消息，然后调用等待方法，等待方法 <strong>需要捕获异常</strong>，否则程序直接因为异常而终止。</p><p>从输出结果上来看，确实是同步调用的，若是异步调用的话应该先输出发送接收再输出阻塞中。</p></li></ol><p><strong>异步方式</strong></p><ol><li><p>配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-comment"># 异步调用</span><br>    <span class="hljs-attr">publisher-confirm-type:</span> <span class="hljs-string">correlated</span><br></code></pre></td></tr></table></figure></li><li><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSendMessage2ExchangeAsync</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">routingKey</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;simple&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello, spring amqp!&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">exchange</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;camq.topic&quot;</span>;<br>    log.info(<span class="hljs-string">&quot;=======发送开始=======&quot;</span>);<br>    rabbitTemplate.convertAndSend(exchange, routingKey, message, <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorrelationData</span>(rabbitTemplate.getUUID()));<br>    rabbitTemplate.setConfirmCallback((correlationData, ack, cause) -&gt; &#123;<br>        log.info(<span class="hljs-string">&quot;接收到了Id为: &#123;&#125; 的回调&quot;</span>, correlationData.getId());<br>        log.info(<span class="hljs-string">&quot;发送结果 -&gt; &#123;&#125;&quot;</span>, ack);<br>        <span class="hljs-keyword">if</span>(!ack) &#123;<br>            log.info(<span class="hljs-string">&quot;失败原因 -&gt; &#123;&#125;&quot;</span>, cause);<br>        &#125;<br>    &#125;);<br>    log.info(<span class="hljs-string">&quot;=======发送结束=======&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>测试结果</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs routeros">10:59:26:788  <span class="hljs-built_in">INFO</span> 3672 --- [           main] cn.itcast.mq.spring.SpringAmqpTest       : =======发送开始=======<br>10:59:26:799  <span class="hljs-built_in">INFO</span> 3672 --- [           main] o.s.a.r.c.CachingConnectionFactory       : Attempting <span class="hljs-keyword">to</span> connect <span class="hljs-keyword">to</span>: [192.168.6.6:5672]<br>10:59:26:892  <span class="hljs-built_in">INFO</span> 3672 --- [           main] o.s.a.r.c.CachingConnectionFactory       : Created new connection: rabbitConnectionFactory#11ee02f8:0/SimpleConnection@48b22fd4 [<span class="hljs-attribute">delegate</span>=amqp://cetuer@192.168.6.6:5672/, localPort= 63202]<br>10:59:26:951  <span class="hljs-built_in">INFO</span> 3672 --- [           main] cn.itcast.mq.spring.SpringAmqpTest       : =======发送结束=======<br>10:59:26:994 <span class="hljs-built_in">ERROR</span> 3672 --- [92.168.6.6:5672] o.s.a.r.c.CachingConnectionFactory       : Channel shutdown: channel error; protocol method: #method&lt;channel.close&gt;(<span class="hljs-attribute">reply-code</span>=404, <span class="hljs-attribute">reply-text</span>=NOT_FOUND - <span class="hljs-literal">no</span> exchange <span class="hljs-string">&#x27;camq.topic&#x27;</span> <span class="hljs-keyword">in</span> vhost <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-attribute">class-id</span>=60, <span class="hljs-attribute">method-id</span>=40)<br>10:59:27:000  <span class="hljs-built_in">INFO</span> 3672 --- [nectionFactory2] cn.itcast.mq.spring.SpringAmqpTest       : 接收到了Id为: 80197111-5b19-474c-9513-6711dc2b3ca5 的回调<br>10:59:27:002  <span class="hljs-built_in">INFO</span> 3672 --- [nectionFactory2] cn.itcast.mq.spring.SpringAmqpTest       : 发送结果 -&gt; <span class="hljs-literal">false</span><br>10:59:27:002  <span class="hljs-built_in">INFO</span> 3672 --- [nectionFactory2] cn.itcast.mq.spring.SpringAmqpTest       : 失败原因 -&gt; channel error; protocol method: #method&lt;channel.close&gt;(<span class="hljs-attribute">reply-code</span>=404, <span class="hljs-attribute">reply-text</span>=NOT_FOUND - <span class="hljs-literal">no</span> exchange <span class="hljs-string">&#x27;camq.topic&#x27;</span> <span class="hljs-keyword">in</span> vhost <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-attribute">class-id</span>=60, <span class="hljs-attribute">method-id</span>=40)<br></code></pre></td></tr></table></figure></li><li><p>分析</p><p>注意，异步方式最好 <strong>指定消息Id</strong> ，否则回调时无法确认是哪条消息。</p><p>经过测试，若成功发送到交换机，则不会触发回调方法。</p></li></ol><h2 id="2-交换机消息未路由到队列"><a href="#2-交换机消息未路由到队列" class="headerlink" title="2. 交换机消息未路由到队列"></a>2. 交换机消息未路由到队列</h2><p>解决此问题同样使用发送者确认机制，不过稍有不同。</p><ul><li>配置属性为 <code>publisher-returns</code></li><li>只有异步方式</li><li>只能配置一个回调</li></ul><p>配置代码：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">publisher-returns:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>由于只能配置一个回调方法，所以选择在所有对象加载完毕后进行配置，配置类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommonConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationContextAware</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setApplicationContext</span><span class="hljs-params">(ApplicationContext applicationContext)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        <span class="hljs-type">RabbitTemplate</span> <span class="hljs-variable">rabbitTemplate</span> <span class="hljs-operator">=</span> applicationContext.getBean(RabbitTemplate.class);<br>        rabbitTemplate.setReturnCallback((message, replyCode, replyText, exchange, routingKey) -&gt; &#123;<br>            log.info(<span class="hljs-string">&quot;消息发送失败,应答码&#123;&#125;,原因&#123;&#125;,交换机&#123;&#125;,路由键&#123;&#125;,消息&#123;&#125;&quot;</span>, replyCode, replyText, exchange, routingKey, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(message.getBody()));<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSendMessage2QueueAsync</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">routingKey</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;simple&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello, spring amqp!&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">exchange</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;amq.topic&quot;</span>;<br>    log.info(<span class="hljs-string">&quot;=======发送开始=======&quot;</span>);<br>    rabbitTemplate.convertAndSend(exchange, routingKey, message);<br>    log.info(<span class="hljs-string">&quot;=======发送结束=======&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">11</span>:<span class="hljs-number">11</span>:<span class="hljs-number">40</span>:<span class="hljs-number">818</span>  INFO <span class="hljs-number">2104</span> ---<span class="hljs-meta"> [           main] cn.itcast.mq.spring.SpringAmqpTest       : =======发送开始=======</span><br><span class="hljs-meta">11:11:40:824  INFO 2104 --- [           main] o.s.a.r.c.CachingConnectionFactory       : Attempting to connect to: [192.168.6.6:5672]</span><br><span class="hljs-attribute">11</span>:<span class="hljs-number">11</span>:<span class="hljs-number">40</span>:<span class="hljs-number">936</span>  INFO <span class="hljs-number">2104</span> ---<span class="hljs-meta"> [           main] o.s.a.r.c.CachingConnectionFactory       : Created new connection: rabbitConnectionFactory#6bd51ed8:0/SimpleConnection@63ec445c [delegate=amqp://cetuer@192.168.6.6:5672/, localPort= 63375]</span><br><span class="hljs-attribute">11</span>:<span class="hljs-number">11</span>:<span class="hljs-number">40</span>:<span class="hljs-number">990</span>  INFO <span class="hljs-number">2104</span> ---<span class="hljs-meta"> [           main] cn.itcast.mq.spring.SpringAmqpTest       : =======发送结束=======</span><br><span class="hljs-meta">11:11:40:991  INFO 2104 --- [nectionFactory1] cn.itcast.mq.config.CommonConfig         : 消息发送失败,应答码312,原因NO_ROUTE,交换机amq.topic,路由键simple,消息hello, spring amqp!</span><br></code></pre></td></tr></table></figure><p>通过结果可以看出，在交换机无法路由到队列时，会异步回调通知发送者路由失败的原因及路由的信息。</p><h2 id="3-队列消息丢失"><a href="#3-队列消息丢失" class="headerlink" title="3. 队列消息丢失"></a>3. 队列消息丢失</h2><p>解决此问题使用持久化交换机、持久化队列、持久化消息即可，代码如下：</p><p><strong>持久化交换机</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title function_">simpleExchange</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 参数分别为 交换机名称、是否持久化、是否自动删除</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DirectExchange</span>(<span class="hljs-string">&quot;simple.direct&quot;</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>持久化队列</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">simpleQueue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 参数分别为 队列名称、是否持久化</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>(<span class="hljs-string">&quot;simple.queue&quot;</span>, <span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>消息持久化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">routingKey</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;simple&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello, spring amqp!&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">exchange</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;simple.direct&quot;</span>;<br><span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> MessageBuilder.withBody(message.getBytes(StandardCharsets.UTF_8))<br>    .setDeliveryMode(MessageDeliveryMode.PERSISTENT).build();<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>默认消息是持久化的</li><li>若想持久化消息必须持久化队列</li></ul><h2 id="4-消费者接收到消息后未消费"><a href="#4-消费者接收到消息后未消费" class="headerlink" title="4. 消费者接收到消息后未消费"></a>4. 消费者接收到消息后未消费</h2><p>解决此问题使用消费者确认机制，即消息者接收到消息后向 <code>MQ</code> 发送 <code>ack</code> 通知，在接收到通知后 <code>MQ</code> 再删除此消息。</p><p><code>Spring AMQP</code> 提供了三种确认模式：</p><ul><li><strong>none</strong>：关闭 <code>ack</code> ，消费者取走消息后就删除此消息，此模式 <strong>会丢失消息</strong>。</li><li><strong>manual</strong>：手动确认模式，即程序员调用方法确认。</li><li><strong>auto</strong>：自动确认，由 <code>Spring</code> 检测 <code>listener</code> 代码，若没有异常则 <code>ack</code>，否则 <code>nack</code>。</li></ul><p><strong>manual 模式</strong></p><ol><li><p>配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">listener:</span><br>      <span class="hljs-attr">simple:</span><br>        <span class="hljs-attr">acknowledge-mode:</span> <span class="hljs-string">manual</span><br></code></pre></td></tr></table></figure></li><li><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringRabbitListener</span> &#123;<br><br>    <span class="hljs-meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenSimpleQueue</span><span class="hljs-params">(<span class="hljs-meta">@Payload</span> String msg, Channel channel, Message message)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        System.out.println(<span class="hljs-string">&quot;消费者接收到simple.queue的消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span>);<br>        System.out.println(<span class="hljs-number">1</span> / <span class="hljs-number">0</span>);<br>        System.out.println(<span class="hljs-string">&quot;消息处理完毕&quot;</span>);<br>        <span class="hljs-comment">// 手动确认</span><br>        channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="hljs-literal">false</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>手动确认时需要再加入两个参数与一个注解，若发生异常导致未调用 <code>basicAck</code> 方法向 <code>MQ</code> 发送确认 <code>ack</code> ，则此消息状态则为 <code>Unacked</code>，消费者重启后消息状态自动变为 <code>ready</code> ，然后被消费。<code>Unacked</code> 消息状态如下图：</p><p><img src="/posts/24168/image-20221112185123208.png" alt="消息状态"></p><p><strong>auto 模式</strong></p><ol><li><p>配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">listener:</span><br>      <span class="hljs-attr">simple:</span><br>        <span class="hljs-attr">acknowledge-mode:</span> <span class="hljs-string">auto</span><br></code></pre></td></tr></table></figure></li><li><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringRabbitListener</span> &#123;<br><br>    <span class="hljs-meta">@RabbitListener(queues = &quot;simple.queue&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">listenSimpleQueue</span><span class="hljs-params">(String msg)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;消费者接收到simple.queue的消息：【&quot;</span> + msg + <span class="hljs-string">&quot;】&quot;</span>);<br>        System.out.println(<span class="hljs-number">1</span> / <span class="hljs-number">0</span>);<br>        System.out.println(<span class="hljs-string">&quot;消息处理完毕&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>启动消费者项目后控制台一直循环报错，陷入了死循环。原因是 <code>auto</code> 模式会自动将消息入队，然后再发送给消费者，消费者再报异常再自动入队，这样就会导致无限循环。</p><p><code>Spring</code> 提供了以下的一些配置来控制重试机制：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">listener:</span><br>      <span class="hljs-attr">simple:</span><br>        <span class="hljs-attr">acknowledge-mode:</span> <span class="hljs-string">auto</span><br>        <span class="hljs-attr">retry:</span><br>          <span class="hljs-comment"># 启用重试机制</span><br>          <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>          <span class="hljs-comment"># 初始重试间隔</span><br>          <span class="hljs-attr">initial-interval:</span> <span class="hljs-string">1000ms</span><br>          <span class="hljs-comment"># 每次增加多少倍时间，即前一次间隔乘以此参数为下一次间隔时间</span><br>          <span class="hljs-attr">multiplier:</span> <span class="hljs-number">2</span><br>          <span class="hljs-comment"># 最大重试次数，第一次也算</span><br>          <span class="hljs-attr">max-attempts:</span> <span class="hljs-number">5</span><br>          <span class="hljs-comment"># true -&gt; 无状态; false -&gt; 有状态，若业务中有事务则为有状态</span><br>          <span class="hljs-attr">stateless:</span> <span class="hljs-literal">true</span><br>          <span class="hljs-comment"># 最大间隔时间，计算出的间隔时间超出此时间则以此时间为准</span><br>          <span class="hljs-attr">max-interval:</span> <span class="hljs-string">5000ms</span><br></code></pre></td></tr></table></figure><p>在重试结束后如果还是出现异常则会使用 <strong>失败消息处理策略</strong> 来处理此消息，有如下三种策略：</p><ul><li>RejectAndDontRequeueRecoverer：丢弃消息，<strong>会丢失消息</strong>， 默认使用此策略。</li><li>ImmediateRequeueMessageRecoverer：返回 <code>nack</code>，消息又会重新入队，这样又会导致无限循环。</li><li>RepublishMessageRecoverer：将消息投递到另一个交换机。</li></ul><p>这里只演示 <code>RepublishMessageRecoverer</code> 策略的情况</p><p>消费者配置代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommonConfig</span> &#123;<br>    <br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Exchange <span class="hljs-title function_">errorExchange</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DirectExchange</span>(<span class="hljs-string">&quot;error.direct&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Queue <span class="hljs-title function_">errorQueue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>(<span class="hljs-string">&quot;error.queue&quot;</span>, <span class="hljs-literal">true</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Binding <span class="hljs-title function_">errorBinding</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(errorQueue()).to(errorExchange()).with(<span class="hljs-string">&quot;error&quot;</span>).noargs();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> MessageRecoverer <span class="hljs-title function_">messageRecoverer</span><span class="hljs-params">(RabbitTemplate rabbitTemplate)</span> &#123;<br>        <span class="hljs-comment">// 指定投递交换机</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RepublishMessageRecoverer</span>(rabbitTemplate, <span class="hljs-string">&quot;error.direct&quot;</span>, <span class="hljs-string">&quot;error&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>重新启动消费者项目并重试结束后，发现消息进入了指定的交换机内</p><p><img src="/posts/24168/image-20221112194426663.png" alt="消息进入失败交换机"></p>]]></content>
    
    
    <categories>
      
      <category>微服务学习</category>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RabbitMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 147</title>
    <link href="/posts/22568.html"/>
    <url>/posts/22568.html</url>
    
    <content type="html"><![CDATA[<h1 id="147-对链表进行插入排序"><a href="#147-对链表进行插入排序" class="headerlink" title="147. 对链表进行插入排序"></a>147. 对链表进行插入排序</h1><p>对链表进行插入排序。</p><span id="more"></span><p><img src="/posts/22568/Insertion-sort-example-300px.gif"></p><p>插入排序的动画演示如上。从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。<br>每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。</p><p><strong>插入排序算法：</strong></p><ol><li>插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。</li><li>每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。</li><li>重复直到所有输入数据插入完为止。</li></ol><p><strong>示例 1：</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入: <span class="hljs-number">4</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span><br>输出: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入: <span class="hljs-number">-1</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">0</span><br>输出: <span class="hljs-number">-1</span>-&gt;<span class="hljs-number">0</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ol><li>如果传入的链表为空，直接<code>return</code>。</li><li>创建哑节点<code>dummyHead</code>，便于在第一个节点前插入元素，初始值为<code>dummyHead.next = head</code>。</li><li>维护已经排序好的最后一个节点<code>lastSorted</code>，初始值为<code>lastSoted = head</code>。</li><li>维护当前要排序的节点<code>current</code>，初始值为<code>head.next</code>。</li><li>比较<code>lastSorted</code>和<code>current</code>：<ul><li><code>lastSorted.val &lt;= current.val</code>时，直接将<code>current</code>列为已排序节点，<code>current</code>节点后移一位。</li><li><code>lastSorted.val &gt; current.val</code>时，维护<code>pre</code>节点，每次比较都置为<code>pre = dummyHead</code>，从<code>dummyHead.next</code>开始循环，找<code>current</code>的插入位置，进行插入。</li></ul></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">insertionSortList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-comment">//为空时直接返回</span><br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> head;<br>        <span class="hljs-comment">//维护哑节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummyHead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>        dummyHead.next = head;<br>        <span class="hljs-comment">//维护已排序的最后一个节点和当前要排序的节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">lastSorted</span> <span class="hljs-operator">=</span> head, current = head.next;<br>        <span class="hljs-comment">//当前要排序的节点为空时表示整个链表已经到头了</span><br>        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">//当已排序的最后一个节点比当前要排序的节点小，无需排序，直接将当前节点纳为已排序节点，因为本就是有序的</span><br>            <span class="hljs-keyword">if</span> (lastSorted.val &lt;= current.val) &#123;<br>                lastSorted = lastSorted.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//维护pre节点，方便插入元素</span><br>                <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> dummyHead<br>                <span class="hljs-comment">//当前要排序节点比已排序节点小，需要从头开始找合适的位置</span><br>                <span class="hljs-keyword">while</span>(pre.next.val &lt; current.val) pre = pre.next;<br>                <span class="hljs-comment">//进行插入</span><br>                lastSorted.next = current.next;<br>                current.next = pre.next;<br>                pre.next = current;<br>            &#125;<br>            <span class="hljs-comment">//当前节点为已排序的节点的下一个节点</span><br>            current = lastSorted.next;<br>        &#125;<br>        <span class="hljs-comment">//返回已排序第一个节点</span><br>        <span class="hljs-keyword">return</span> dummyHead.next;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="/posts/22568/image-20201120234944593.png"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 118</title>
    <link href="/posts/3179.html"/>
    <url>/posts/3179.html</url>
    
    <content type="html"><![CDATA[<h1 id="118-杨辉三角"><a href="#118-杨辉三角" class="headerlink" title="118. 杨辉三角"></a>118. 杨辉三角</h1><p>给定一个非负整数 <em>numRows，</em>生成杨辉三角的前 <em>numRows</em> 行。</p><span id="more"></span><p><img src="/posts/3179/PascalTriangleAnimated2.gif"></p><p>在杨辉三角中，每个数是它左上方和右上方的数的和。</p><p><strong>示例:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: 5<br>输出:<br><span class="hljs-comment">[</span><br><span class="hljs-comment">     <span class="hljs-comment">[1]</span>,</span><br><span class="hljs-comment">    <span class="hljs-comment">[1,1]</span>,</span><br><span class="hljs-comment">   <span class="hljs-comment">[1,2,1]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[1,3,3,1]</span>,</span><br><span class="hljs-comment"> <span class="hljs-comment">[1,4,6,4,1]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先把1赋值，左右两边。左边：<code>a[0][0]、a[1][0]……a[n-1][0]</code>，右边：<code>a[0][0]、a[1][1]、a[2][2]、a[n-1][n-1]</code>。</p><p>然后除了赋值1剩下的填充规则是：上一行再减一列的元素加上一行对应的元素就是本次该填充的元素值。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">generate</span><span class="hljs-params">(<span class="hljs-type">int</span> numRows)</span> &#123;<br>        List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numRows; i++) &#123;<br>            <span class="hljs-comment">//每一行元素</span><br>            List&lt;Integer&gt; row = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt;= i; j++) &#123;<br>                <span class="hljs-comment">//最边一列和最右边一列赋值为1</span><br>                <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span> || j == i)<br>                    row.add(<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">else</span><br>                    <span class="hljs-comment">//上一行减一列元素加上一行对应元素</span><br>                    row.add(ans.get(i - <span class="hljs-number">1</span>).get(j - <span class="hljs-number">1</span>) + ans.get(i - <span class="hljs-number">1</span>).get(j));<br>            &#125;<br>            ans.add(row);<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="/posts/3179/image-20201206120318564.png"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IDEA启动SpringBoot项目卡住</title>
    <link href="/posts/40030.html"/>
    <url>/posts/40030.html</url>
    
    <content type="html"><![CDATA[<p>最近在做一个项目时，突然 IDEA 就像抽风一样，运行一个 Spring Boot 项目直接就卡住在 <code>Starting 项目名</code> <span id="more"></span>，如图所示这样</p><p><img src="/posts/40030/block-16388840299031.gif"></p><p><strong>解决方法：</strong> 在工程目录  <code>.idea/workspace.xml</code>  文件找到 <code>&lt;component name=&quot;PropertiesComponent&quot;&gt;</code> 的标签下添加一行代码 <code> &lt;property name=&quot;dynamic.classpath&quot; value=&quot;true&quot; /&gt;</code> 即可解决上述问题，就像下面这样：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;PropertiesComponent&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dynamic.classpath&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br>    ......<br><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span><br></code></pre></td></tr></table></figure><p>谈一下卡住的原因以及我的找错历程。</p><p>刚开始以为是项目问题，后来通过新建项目进行复原，发现似乎依赖加多了就会卡住，依赖少的话就不会卡死。再通过重装 maven、jdk、以及系统后基本排除运行环境问题。</p><p>今天下午在继续找原因时偶然发现运行后的命令行有点长的离谱，指的是这里的命令行</p><p><img src="/posts/40030/image-20211207215036079.png"></p><p>放张图看一下命令行长的有多离谱</p><p><img src="/posts/40030/image-20211207214943890.png"></p><p>通过命令行不难看出，IDEA 把所有依赖的 jar 包都放在命令行一个个进行依赖了，所以才会导致启动项目时会卡住，既然找到了原因也就不难解决了，把这些依赖设置为动态 classpath 就好了，就是上面的解决方法，操作后生成的命令行如下</p><p><img src="/posts/40030/image-20211207215604849.png"></p><p>简短了很多，所以运行起来就不会卡住不动啦，完美解决。</p>]]></content>
    
    
    <categories>
      
      <category>IntelliJ IDEA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IntelliJ IDEA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 429</title>
    <link href="/posts/15802.html"/>
    <url>/posts/15802.html</url>
    
    <content type="html"><![CDATA[<h1 id="429-N叉树的层序遍历"><a href="#429-N叉树的层序遍历" class="headerlink" title="429. N叉树的层序遍历"></a>429. N叉树的层序遍历</h1><p>给定一个 N 叉树，返回其节点值的<em>层序遍历</em>。（即从左到右，逐层遍历）。</p><p>树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。</p> <span id="more"></span><p><strong>示例 1：</strong></p><p><img src="/posts/15802/narytreeexample.png"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[1,null,3,2,4,null,5,6]</span><br>输出：<span class="hljs-comment">[<span class="hljs-comment">[1]</span>,<span class="hljs-comment">[3,2,4]</span>,<span class="hljs-comment">[5,6]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="/posts/15802/sample_4_964.png"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">输入：root = [<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">8</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">11</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">12</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">13</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">14</span>]<br>输出：[[<span class="hljs-number">1</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>],[<span class="hljs-number">11</span>,<span class="hljs-number">12</span>,<span class="hljs-number">13</span>],[<span class="hljs-number">14</span>]]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树的高度不会超过 <code>1000</code></li><li>树的节点总数在 <code>[0, 10^4]</code> 之间</li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>最容易想到的就是经典的广搜，这里需要注意一个小细节，是一层放到一个 <code>List</code> 中的，所以要知道每一层的大小。</p><p>然后是递归，参数里要传一个当前层数，以便保存当前层的数据。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>迭代：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(Node root)</span> &#123;<br>    Deque&lt;Node&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>    List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    queue.add(root);<br>    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>        List&lt;Integer&gt; level = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> queue.poll();<br>            level.add(tmp.val);<br>            queue.addAll(tmp.children);<br>        &#125;<br>        ans.add(level);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>递归：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(Node root)</span> &#123;<br>    <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">null</span>) traverseNode(root, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">traverseNode</span><span class="hljs-params">(Node node, <span class="hljs-type">int</span> level)</span> &#123;<br>    <span class="hljs-keyword">if</span>(ans.size() &lt;= level) &#123;<br>        ans.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;());<br>    &#125;<br>    ans.get(level).add(node.val);<br>    <span class="hljs-keyword">for</span> (Node n: node.children) &#123;<br>        traverseNode(n, level + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>递归：</p><p><img src="/posts/15802/image-20210503221730117.png"></p><p>迭代：</p><p><img src="/posts/15802/image-20210503221819501.png"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树</tag>
      
      <tag>广度优先搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 590</title>
    <link href="/posts/52012.html"/>
    <url>/posts/52012.html</url>
    
    <content type="html"><![CDATA[<h1 id="590-N叉树的后序遍历"><a href="#590-N叉树的后序遍历" class="headerlink" title="590. N叉树的后序遍历"></a>590. N叉树的后序遍历</h1><p>给定一个 N 叉树，返回其节点值的 <strong>后序遍历</strong> 。</p><p>N 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 <code>null</code> 分隔（请参见示例）。</p><p><strong>进阶：</strong></p><p>递归法很简单，你可以使用迭代法完成此题吗?</p> <span id="more"></span><p><strong>示例 1：</strong></p><p> <img src="/posts/52012/narytreeexample.png"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>输出：[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="/posts/52012/sample_4_964.png"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">输入：root = [<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">8</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">11</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">12</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">13</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">14</span>]<br>输出：[<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">14</span>,<span class="hljs-number">11</span>,<span class="hljs-number">7</span>,<span class="hljs-number">3</span>,<span class="hljs-number">12</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">13</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>N 叉树的高度小于或等于 <code>1000</code></li><li>节点总数在范围 <code>[0, 10^4]</code> 内</li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>递归很简单，不分析了。</p><p>迭代参考 <a href="/posts/24045.html" title="LeetCode 589">N叉树的前序遍历</a> 思路，最后翻转一下数组即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>递归：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">postorder</span><span class="hljs-params">(Node root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (Node node : root.children) &#123;<br>        postorder(node);<br>    &#125;<br>    ans.add(root.val);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>迭代：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">postorder</span><span class="hljs-params">(Node root)</span> &#123;<br>    List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    Deque&lt;Node&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>    stack.push(root);<br>    <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> stack.pop();<br>        ans.add(tmp.val);<br>        <span class="hljs-keyword">for</span> (Node node : tmp.children) &#123;<br>            stack.push(node);<br>        &#125;<br>    &#125;<br>    Collections.reverse(ans);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>递归：</p><p><img src="/posts/52012/image-20210503193523283.png"></p><p>迭代：</p><p><img src="/posts/52012/image-20210503193540107.png"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 589</title>
    <link href="/posts/24045.html"/>
    <url>/posts/24045.html</url>
    
    <content type="html"><![CDATA[<h1 id="589-N叉树的前序遍历"><a href="#589-N叉树的前序遍历" class="headerlink" title="589. N叉树的前序遍历"></a>589. N叉树的前序遍历</h1><p>给定一个 N 叉树，返回其节点值的 <strong>前序遍历</strong> 。</p><p>N 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 <code>null</code> 分隔（请参见示例）。</p><p><strong>进阶：</strong></p><p>递归法很简单，你可以使用迭代法完成此题吗?</p><span id="more"></span><p><strong>示例 1：</strong></p><p><img src="/posts/24045/narytreeexample.png"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">root</span> = [<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="/posts/24045/sample_4_964-1620034726648.png"></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">输入：root = [<span class="hljs-number">1</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">8</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">11</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">12</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">13</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">14</span>]<br>输出：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">11</span>,<span class="hljs-number">14</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">12</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>,<span class="hljs-number">13</span>,<span class="hljs-number">10</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>N 叉树的高度小于或等于 <code>1000</code></li><li>节点总数在范围 <code>[0, 10^4]</code> 内</li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>递归很简单，就不分析了。</p><p>迭代自己手动维护一个栈，每次取栈顶元素，然后把其所有子节点逆置压入栈中。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>递归：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">preorder</span><span class="hljs-params">(Node root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    ans.add(root.val);<br>    <span class="hljs-keyword">for</span> (Node children : root.children) &#123;<br>        preorder(children);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><p>迭代：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">preorder</span><span class="hljs-params">(Node root)</span> &#123;<br>    List&lt;Integer&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    Deque&lt;Node&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>    stack.push(root);<br>    <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>        root = stack.pop();<br>        ans.add(root.val);<br>        Collections.reverse(root.children);<br>        <span class="hljs-keyword">for</span> (Node node: root.children) &#123;<br>            stack.push(node);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>递归：</p><p><img src="/posts/24045/image-20210503174254614.png"></p><p>迭代：</p><p><img src="/posts/24045/image-20210503174312955.png"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 145</title>
    <link href="/posts/39337.html"/>
    <url>/posts/39337.html</url>
    
    <content type="html"><![CDATA[<h1 id="145-二叉树的后序遍历"><a href="#145-二叉树的后序遍历" class="headerlink" title="145. 二叉树的后序遍历"></a>145. 二叉树的后序遍历</h1><p>给定一个二叉树，返回它的 <em>后序</em> 遍历。</p><p><strong>示例:</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入: <span class="hljs-comment">[1,null,2,3]</span>  <br>   1<br>    \<br>     2<br>    /<br>   3 <br><br>输出: <span class="hljs-comment">[3,2,1]</span><br></code></pre></td></tr></table></figure><p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p><span id="more"></span><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>和 <a href="/posts/26862.html" title="LeetCode 94">二叉树的中序遍历</a> 一样的思路，不过迭代写法中后序遍历多了一个 <code>prev</code> 用来保存上一次访问过的节点，防止重复访问。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>递归：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postorder</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; res)</span> &#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    postorder(root.left, res);<br>    postorder(root.right, res);<br>    res.add(root.val);<br>&#125;<br><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    postorder(root, res);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>迭代：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    Deque&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">while</span> (!stack.isEmpty() || root != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">null</span>) &#123;<br>            stack.push(root);<br>            root = root.left;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            root = stack.peek();<br>            <span class="hljs-keyword">if</span>(root.right == <span class="hljs-literal">null</span> || prev == root.right) &#123;<br>                res.add(root.val);<br>                prev = root;<br>                stack.pop();<br>                root = <span class="hljs-literal">null</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                root = root.right;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>递归：</p><p><img src="/posts/39337/image-20210503154220267.png"></p><p>迭代：</p><p><img src="/posts/39337/image-20210503154240505.png"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 144</title>
    <link href="/posts/22888.html"/>
    <url>/posts/22888.html</url>
    
    <content type="html"><![CDATA[<h1 id="144-二叉树的前序遍历"><a href="#144-二叉树的前序遍历" class="headerlink" title="144. 二叉树的前序遍历"></a>144. 二叉树的前序遍历</h1><p>给你二叉树的根节点 <code>root</code> ，返回它节点值的 <strong>前序</strong> 遍历。</p><span id="more"></span><p><strong>示例 1：</strong></p><p><img src="/posts/22888/inorder_1.jpg"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[1,null,2,3]</span><br>输出：<span class="hljs-comment">[1,2,3]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[1]</span><br>输出：<span class="hljs-comment">[1]</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><p><img src="/posts/22888/inorder_5.jpg"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[1,2]</span><br>输出：<span class="hljs-comment">[1,2]</span><br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><p><img src="/posts/22888/inorder_4.jpg"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[1,null,2]</span><br>输出：<span class="hljs-comment">[1,2]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 100]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><p><strong>进阶：</strong>递归算法很简单，你可以通过迭代算法完成吗？</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>和 <a href="/posts/26862.html" title="LeetCode 94">二叉树的中序遍历</a> 一样的思路。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>递归：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preorder</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; res)</span> &#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    res.add(root.val);<br>    preorder(root.left, res);<br>    preorder(root.right, res);<br>&#125;<br><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    preorder(root, res);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>迭代：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span>  List&lt;Integer&gt; <span class="hljs-title function_">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    Deque&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>    <span class="hljs-keyword">while</span> (!stack.isEmpty() || root != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">null</span>) &#123;<br>            res.add(root.val);<br>            stack.push(root);<br>            root = root.left;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            root = stack.pop().right;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>递归：</p><p><img src="/posts/22888/image-20210503124502845.png"></p><p>迭代：</p><p><img src="/posts/22888/image-20210503124520906.png"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 94</title>
    <link href="/posts/26862.html"/>
    <url>/posts/26862.html</url>
    
    <content type="html"><![CDATA[<h1 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a>94. 二叉树的中序遍历</h1><p>给定一个二叉树的根节点 <code>root</code> ，返回它的 <strong>中序</strong> 遍历。</p> <span id="more"></span><p><strong>示例 1：</strong></p><p><img src="/posts/26862/inorder_1.jpg"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[1,null,2,3]</span><br>输出：<span class="hljs-comment">[1,3,2]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[1]</span><br>输出：<span class="hljs-comment">[1]</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><p><img src="/posts/26862/inorder_5.jpg"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[1,2]</span><br>输出：<span class="hljs-comment">[2,1]</span><br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><p><img src="/posts/26862/inorder_5-1619184221963.jpg"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：root = <span class="hljs-comment">[1,null,2]</span><br>输出：<span class="hljs-comment">[1,2]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[0, 100]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><p><strong>进阶:</strong> 递归算法很简单，你可以通过迭代算法完成吗？</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>经典题目，两种方法，递归和迭代</p><p>迭代就是我们自己维护一个栈，模拟递归操作。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>递归：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">inorder</span><span class="hljs-params">(TreeNode root, List&lt;Integer&gt; res)</span> &#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>    inorder(root.left, res);<br>    res.add(root.val);<br>    inorder(root.right, res);<br>&#125;<br><br><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    inorder(root, res);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>迭代：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>   List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>   Deque&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br>   <span class="hljs-keyword">while</span> (!stack.isEmpty() || root != <span class="hljs-literal">null</span>) &#123;<br>       <span class="hljs-keyword">if</span>(root != <span class="hljs-literal">null</span>) &#123;<br>           stack.push(root);<br>           root = root.left;<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>           <span class="hljs-type">TreeNode</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> stack.pop();<br>           res.add(tmp.val);<br>           root = tmp.right;<br>       &#125;<br>   &#125;<br>   <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>递归：</p><p><img src="/posts/26862/image-20210423212607744.png"></p><p>迭代：</p><p><img src="/posts/26862/image-20210423220600465.png"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>栈</tag>
      
      <tag>树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 155</title>
    <link href="/posts/2472.html"/>
    <url>/posts/2472.html</url>
    
    <content type="html"><![CDATA[<h1 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a>155. 最小栈</h1><p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p><ul><li><code>push(x)</code> —— 将元素 x 推入栈中。</li><li><code>pop()</code> —— 删除栈顶的元素。</li><li><code>top()</code> —— 获取栈顶元素。</li><li><code>getMin()</code> —— 检索栈中的最小元素。</li></ul><span id="more"></span><p><strong>示例:</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：<br>[<span class="hljs-string">&quot;MinStack&quot;</span>,<span class="hljs-string">&quot;push&quot;</span>,<span class="hljs-string">&quot;push&quot;</span>,<span class="hljs-string">&quot;push&quot;</span>,<span class="hljs-string">&quot;getMin&quot;</span>,<span class="hljs-string">&quot;pop&quot;</span>,<span class="hljs-string">&quot;top&quot;</span>,<span class="hljs-string">&quot;getMin&quot;</span>]<br>[[],[<span class="hljs-number">-2</span>],[<span class="hljs-number">0</span>],[<span class="hljs-number">-3</span>],[],[],[],[]]<br><br>输出：<br>[null,null,null,null,<span class="hljs-number">-3</span>,null,<span class="hljs-number">0</span>,<span class="hljs-number">-2</span>]<br><br>解释：<br><span class="hljs-symbol">MinStack</span> minStack = new <span class="hljs-symbol">MinStack</span>();<br>minStack.push(<span class="hljs-number">-2</span>);<br>minStack.push(<span class="hljs-number">0</span>);<br>minStack.push(<span class="hljs-number">-3</span>);<br>minStack.getMin();   --&gt; 返回 <span class="hljs-number">-3.</span><br>minStack.pop();<br>minStack.top();      --&gt; 返回 <span class="hljs-number">0.</span><br>minStack.getMin();   --&gt; 返回 <span class="hljs-number">-2.</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>pop</code>、<code>top</code> 和 <code>getMin</code> 操作总是在 <strong>非空栈</strong> 上调用。</li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>使用辅助栈保存对应的最小值即可，我为了简单，直接把两个栈合并为一个，自己实现一个链栈。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br>    <span class="hljs-keyword">private</span> Node head;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * initialize your data structure here.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MinStack</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.head == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-built_in">this</span>.head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(val, val, <span class="hljs-literal">null</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">this</span>.head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(val, Math.min(val, <span class="hljs-built_in">this</span>.head.min), head);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.head = <span class="hljs-built_in">this</span>.head.next;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.head.val;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getMin</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.head.min;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>        <span class="hljs-type">int</span> val;<br>        <span class="hljs-type">int</span> min;<br>        Node next;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Node</span><span class="hljs-params">(<span class="hljs-type">int</span> val, <span class="hljs-type">int</span> min, Node next)</span> &#123;<br>            <span class="hljs-built_in">this</span>.val = val;<br>            <span class="hljs-built_in">this</span>.min = min;<br>            <span class="hljs-built_in">this</span>.next = next;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="/posts/2472/image-20210423203546427.png"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>栈</tag>
      
      <tag>设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 20</title>
    <link href="/posts/39912.html"/>
    <url>/posts/39912.html</url>
    
    <content type="html"><![CDATA[<h1 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a>20. 有效的括号</h1><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ol><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;()&quot;</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><span id="more"></span><p><strong>示例 2：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;()[]&#123;&#125;&quot;</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;(]&quot;</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;([)]&quot;</span><br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;&#123;[]&#125;&quot;</span><br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 10^4</code></li><li><code>s</code> 仅由括号 <code>&#39;()[]&#123;&#125;&#39;</code> 组成</li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>栈的经典题目了，这里用一个小技巧，遇到左括号，将对应的右括号推入栈中，取出的时候只需判断是否相等就行了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isValid</span><span class="hljs-params">(String s)</span> &#123;<br>    <span class="hljs-keyword">if</span>(s == <span class="hljs-literal">null</span> || s.length() % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span>  <span class="hljs-literal">false</span>;<br>    &#125;<br>    Deque&lt;Character&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayDeque</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>        <span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> s.charAt(i);<br>        <span class="hljs-keyword">switch</span> (c)<br>        &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span> :<br>                stack.push(<span class="hljs-string">&#x27;)&#x27;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;[&#x27;</span>:<br>                stack.push(<span class="hljs-string">&#x27;]&#x27;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;&#123;&#x27;</span>:<br>                stack.push(<span class="hljs-string">&#x27;&#125;&#x27;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">if</span>(stack.isEmpty() || c != stack.peek()) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                stack.pop();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> stack.isEmpty();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="/posts/39912/image-20210423104041996.png"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-66</title>
    <link href="/posts/39675.html"/>
    <url>/posts/39675.html</url>
    
    <content type="html"><![CDATA[<h1 id="66-加一"><a href="#66-加一" class="headerlink" title="66. 加一"></a>66. 加一</h1><p>给定一个由 <strong>整数</strong> 组成的 <strong>非空</strong> 数组所表示的非负整数，在该数的基础上加一。</p><p>最高位数字存放在数组的首位， 数组中每个元素只存储<strong>单个</strong>数字。</p><p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p><span id="more"></span><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：digits = <span class="hljs-comment">[1,2,3]</span><br>输出：<span class="hljs-comment">[1,2,4]</span><br>解释：输入数组表示数字 123。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：digits = [<span class="hljs-number">4,3,2,1</span>]<br>输出：[<span class="hljs-number">4,3,2,2</span>]<br>解释：输入数组表示数字 <span class="hljs-number">4321</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：digits = <span class="hljs-comment">[0]</span><br>输出：<span class="hljs-comment">[1]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= digits.length &lt;= 100</code></li><li><code>0 &lt;= digits[i] &lt;= 9</code></li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>加一，分为两种情况：</p><ul><li>除 <code>9</code> 之外的数字加一</li><li><code>9</code> 加一</li></ul><p>对于加一来说，只要是非 <code>9</code> 的数字，加完一后就可以返回了，如果是 <code>9</code> 则需要进位，下一位依然要加一，如果第一位是 <code>9</code> ，比如：<code>9</code>，<code>99</code>等，这时需要将数组扩容，且第一位一定为 <code>1</code>，其余一定为 <code>0</code>。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] plusOne(<span class="hljs-type">int</span>[] digits) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> digits.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        digits[i]++;<br>        digits[i] %= <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">if</span>(digits[i] != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> digits;<br>    &#125;<br>    digits = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[digits.length + <span class="hljs-number">1</span>];<br>    digits[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> digits;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="/posts/39675/image-20210410151859530.png"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-88</title>
    <link href="/posts/15998.html"/>
    <url>/posts/15998.html</url>
    
    <content type="html"><![CDATA[<h1 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88. 合并两个有序数组"></a>88. 合并两个有序数组</h1><p>给你两个有序整数数组 <code>nums1</code> 和 <code>nums2</code>，请你将 <code>nums2</code> 合并到 <code>nums1</code> 中<em>，</em>使 <code>nums1</code> 成为一个有序数组。</p><p>初始化 <code>nums1</code> 和 <code>nums2</code> 的元素数量分别为 <code>m</code> 和 <code>n</code> 。你可以假设 <code>nums1</code> 的空间大小等于 <code>m + n</code>，这样它就有足够的空间保存来自 <code>nums2</code> 的元素。</p><span id="more"></span><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums1 = <span class="hljs-comment">[1,2,3,0,0,0]</span>, m = 3, nums2 = <span class="hljs-comment">[2,5,6]</span>, n = 3<br>输出：<span class="hljs-comment">[1,2,2,3,5,6]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums1 = <span class="hljs-comment">[1]</span>, m = 1, nums2 = <span class="hljs-comment">[]</span>, n = 0<br>输出：<span class="hljs-comment">[1]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>nums1.length == m + n</code></li><li><code>nums2.length == n</code></li><li><code>0 &lt;= m, n &lt;= 200</code></li><li><code>1 &lt;= m + n &lt;= 200</code></li><li><code>-10^9 &lt;= nums1[i], nums2[i] &lt;= 10^9</code></li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>三种方法</p><ul><li>第一种直接把 <code>nums2</code> 元素放到 <code>nums1</code> 数组尾部，然后排序，过于简单，就不写了</li><li>第二种，开辟 <code>nums3</code> 数组，按序将 <code>nums1</code> <code>nums2</code> 放进去，再将 <code>nums3</code> 复制到 <code>nums1</code> 中，这个也没啥难度，跳过</li><li>第三种，使用几个指针，<code>p</code> 指向 <code>nums1</code> 数组尾部元素，<code>q</code> 指向 <code>nums2</code> 数组尾部元素，<code>tail</code> 指向 <code>nums1</code> 数组尾部，接下来只需考虑几种情况移动元素即可：<ul><li><code>p</code> 移动到了 <code>-1</code> ，只需移动 <code>q</code>指针指向的元素到 <code>tail</code></li><li><code>q</code> 移动到了 <code>-1</code>， 只需移动 <code>p</code> 指针指向的元素到 <code>tail</code></li><li><code>p</code>和 <code>q</code> 均不为 <code>-1</code>，两个指针指向较大元素移动到 <code>tail</code>，指针前移</li><li>最后 <code>tail</code> 指针前移</li></ul></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">merge</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> m - <span class="hljs-number">1</span>, q = n - <span class="hljs-number">1</span>, tail = m + n - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> cur;<br>    <span class="hljs-keyword">while</span> (p &gt;= <span class="hljs-number">0</span> || q &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span>(p == -<span class="hljs-number">1</span>) &#123;<br>            cur = nums2[q--];<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(q == -<span class="hljs-number">1</span>) &#123;<br>            cur = nums1[p--];<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums1[p] &gt; nums2[q]) &#123;<br>            cur = nums1[p--];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cur = nums2[q--];<br>        &#125;<br>        nums1[tail--] = cur;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="/posts/15998/image-20210410145249690.png"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-21</title>
    <link href="/posts/39096.html"/>
    <url>/posts/39096.html</url>
    
    <content type="html"><![CDATA[<h1 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a>21. 合并两个有序链表</h1><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><span id="more"></span><p><strong>示例 1：</strong></p><p><img src="/posts/39096/merge_ex1.jpg"></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[1,2,4]</span>, l2 = <span class="hljs-comment">[1,3,4]</span><br>输出：<span class="hljs-comment">[1,1,2,3,4,4]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[]</span>, l2 = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：l1 = <span class="hljs-comment">[]</span>, l2 = <span class="hljs-comment">[0]</span><br>输出：<span class="hljs-comment">[0]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>两个链表的节点数目范围是 <code>[0, 50]</code></li><li><code>-100 &lt;= Node.val &lt;= 100</code></li><li><code>l1</code> 和 <code>l2</code> 均按 <strong>非递减顺序</strong> 排列</li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ol><li>递归：<ul><li>如果 <code>l1</code> 为空了，就返回 <code>l2</code> ，说不定 <code>l2</code> 还有元素，同理如果 <code>l2</code> 空了就返回 <code>l1</code></li><li>然后就是剩下结点的比较，找出较小的节点，使其下一个节点为合并好的链表，最后返回此链表</li></ul></li><li>迭代：<ul><li>生成一个 <code>dummyHead</code> 节点和 <code>prev</code> 指针，便于操作</li><li>先考虑两个链表都不为空的情况，将较小的节点插入到 <code>prev</code> 指针后，然后 <code>prev</code> 指针后移</li><li>其中一个链表为空时只需将另一个链表接在 <code>prev</code> 指针后即可，注意最后返回 <code>dummyHead.next</code></li></ul></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>递归：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>    <span class="hljs-keyword">if</span>(l1 == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span> l2;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(l2 == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span> l1;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(l1.val &lt; l2.val) &#123;<br>        l1.next = mergeTwoLists(l1.next, l2);<br>        <span class="hljs-keyword">return</span> l1;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        l2.next = mergeTwoLists(l1, l2.next);<br>        <span class="hljs-keyword">return</span> l2;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>迭代：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummyHead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>, <span class="hljs-literal">null</span>), prev = dummyHead;<br>    <span class="hljs-keyword">while</span> (l1 != <span class="hljs-literal">null</span> &amp;&amp; l2 != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span>(l1.val &lt; l2.val) &#123;<br>            prev.next = l1;<br>            l1 = l1.next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            prev.next = l2;<br>            l2 = l2.next;<br>        &#125;<br>        prev = prev.next;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(l1 == <span class="hljs-literal">null</span>) &#123;<br>        prev.next = l2;<br>    &#125; <span class="hljs-keyword">else</span>  &#123;<br>        prev.next = l1;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummyHead.next;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>递归：</p><p><img src="/posts/39096/image-20210408220458306.png"></p><p>迭代：</p><p><img src="/posts/39096/image-20210408221607442.png"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
      <tag>递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-189</title>
    <link href="/posts/12462.html"/>
    <url>/posts/12462.html</url>
    
    <content type="html"><![CDATA[<h1 id="189-旋转数组"><a href="#189-旋转数组" class="headerlink" title="189. 旋转数组"></a>189. 旋转数组</h1><p>给定一个数组，将数组中的元素向右移动 <code>k</code> 个位置，其中 <code>k</code> 是非负数。</p><p><strong>进阶：</strong></p><ul><li>尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。</li><li>你可以使用空间复杂度为 O(1) 的 <strong>原地</strong> 算法解决这个问题吗？</li></ul><span id="more"></span><p><strong>示例 1:</strong></p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">输入</span><span class="hljs-punctuation">:</span> <span class="hljs-string">nums = [1,2,3,4,5,6,7], k = 3</span><br><span class="hljs-attribute">输出</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[5,6,7,1,2,3,4]</span><br><span class="hljs-attribute">解释</span><span class="hljs-punctuation">:</span><br><span class="hljs-attribute">向右旋转 1 步</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[7,1,2,3,4,5,6]</span><br><span class="hljs-attribute">向右旋转 2 步</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[6,7,1,2,3,4,5]</span><br><span class="hljs-attribute">向右旋转 3 步</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[5,6,7,1,2,3,4]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [<span class="hljs-string">-1</span>,<span class="hljs-string">-100</span>,3,99], k = 2<br>输出：[3,99,<span class="hljs-string">-1</span>,<span class="hljs-string">-100</span>]<br>解释: <br>向右旋转 1 步: [99,<span class="hljs-string">-1</span>,<span class="hljs-string">-100</span>,3]<br>向右旋转 2 步: [3,99,<span class="hljs-string">-1</span>,<span class="hljs-string">-100</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2 * 10^4</code></li><li><code>-2^31 &lt;= nums[i] &lt;= 2^31 - 1</code></li><li><code>0 &lt;= k &lt;= 10^5</code></li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ol><li>使用额外数组：另外创建个数组储存旋转后的数组，最后复制回去，旋转后的位置即为 <code>(i + k) % nums.length</code>。</li><li>翻转数组：设 <code>nums = [1, 2, 3, 4, 5], k = 3</code>，先总体翻转，反转后为 <code>5, 4, 3, 2, 1</code> ，然后再翻转前 <code>k % length</code> 个，为 <code>3, 4, 5, 2, 1</code> ，最后翻转剩下的，结果为 <code>3, 4, 5, 1, 2</code> ，即为我们想要的结果。</li><li></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>额外数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-type">int</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[nums.length];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        temp[(i+k)%nums.length] = nums[i];<br>    &#125;<br>    System.arraycopy(temp, <span class="hljs-number">0</span>, nums, <span class="hljs-number">0</span>, nums.length);<br>&#125;<br></code></pre></td></tr></table></figure><p>翻转：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>    k %= nums.length;<br>    reverse(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>    reverse(nums, <span class="hljs-number">0</span>, k - <span class="hljs-number">1</span>);<br>    reverse(nums, k, nums.length - <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>    <span class="hljs-keyword">while</span> (start &lt; end) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> nums[start];<br>        nums[start] = nums[end];<br>        nums[end] = tmp;<br>        start++;<br>        end--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>额外数组：</p><p><img src="/posts/12462/image-20210408170812241.png"></p><p>翻转数组：</p><p><img src="/posts/12462/image-20210408172734067.png"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-26</title>
    <link href="/posts/23289.html"/>
    <url>/posts/23289.html</url>
    
    <content type="html"><![CDATA[<h1 id="26-删除有序数组中的重复项"><a href="#26-删除有序数组中的重复项" class="headerlink" title="26. 删除有序数组中的重复项"></a>26. 删除有序数组中的重复项</h1><p>给你一个有序数组 <code>nums</code> ，请你**<a href="http://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在 <strong><a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95">原地 </a>修改输入数组</strong> 并在使用 O(1) 额外空间的条件下完成。</p><span id="more"></span><p><strong>说明:</strong></p><p>为什么返回数值是整数，但输出的答案是数组呢?</p><p>请注意，输入数组是以<strong>「引用」</strong>方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。</p><p>你可以想象内部操作如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝</span><br><span class="hljs-type">int</span> <span class="hljs-built_in">len</span> = removeDuplicates(nums);<br><br><span class="hljs-comment">// 在函数里修改输入数组对于调用者是可见的。</span><br><span class="hljs-comment">// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>; i++) &#123;<br>    <span class="hljs-built_in">print</span>(nums[i]);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,1,2]</span><br>输出：2, nums = <span class="hljs-comment">[1,2]</span><br>解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">0,0,1,1</span>,<span class="hljs-number">1,2,2,3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>输出：<span class="hljs-number">5</span>, nums = [<span class="hljs-number">0,1,2,3</span>,<span class="hljs-number">4</span>]<br>解释：函数应该返回新的长度 <span class="hljs-number">5</span> ， 并且原数组 nums 的前五个元素被修改为 <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span> 。不需要考虑数组中超出新长度后面的元素。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 3 * 10^4</code></li><li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li><li><code>nums</code> 已按升序排列</li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>水题，使用双指针，初始 <code>i</code> 指向第一个元素，<code>j</code> 指向第二个元素，如果两个指针指向的值不相等，则 <code>i++</code> 把 <code>j</code> 指向的值赋值给 <code>i</code> 指向的地址，如果相等，则直接 <code>j++</code>，最后长度为 <code>i+1</code>。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">removeDuplicates</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; nums.length; j++) &#123;<br>        <span class="hljs-keyword">if</span> (nums[i] != nums[j]) &#123;<br>            nums[++i] = nums[j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="/posts/23289/image-20210407181354329.png"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-25</title>
    <link href="/posts/23481.html"/>
    <url>/posts/23481.html</url>
    
    <content type="html"><![CDATA[<h1 id="25-K个一组翻转链表"><a href="#25-K个一组翻转链表" class="headerlink" title="25. K个一组翻转链表"></a>25. K个一组翻转链表</h1><p>给你一个链表，每 <em>k</em> 个节点一组进行翻转，请你返回翻转后的链表。</p><p><em>k</em> 是一个正整数，它的值小于或等于链表的长度。</p><p>如果节点总数不是 <em>k</em> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p><strong>进阶：</strong></p><ul><li>你可以设计一个只使用常数额外空间的算法来解决此问题吗？</li><li><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际进行节点交换。</li></ul><span id="more"></span><p> <strong>示例 1：</strong></p><p><img src="/posts/23481/reverse_ex1.jpg"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：head = <span class="hljs-string">[1,2,3,4,5]</span>, k = <span class="hljs-number">2</span><br>输出：<span class="hljs-string">[2,1,4,3,5]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="/posts/23481/reverse_ex2.jpg"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：head = <span class="hljs-string">[1,2,3,4,5]</span>, k = <span class="hljs-number">3</span><br>输出：<span class="hljs-string">[3,2,1,4,5]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：head = <span class="hljs-string">[1,2,3,4,5]</span>, k = <span class="hljs-number">1</span><br>输出：<span class="hljs-string">[1,2,3,4,5]</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1]</span>, k = 1<br>输出：<span class="hljs-comment">[1]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><p>列表中节点的数量在范围 <code>sz</code> 内</p></li><li><p><code>1 &lt;= sz &lt;= 5000</code></p></li><li><p><code>0 &lt;= Node.val &lt;= 1000</code></p></li><li><p><code>1 &lt;= k &lt;= sz</code></p></li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>翻转链表函数之前做过了，这里直接拿来用。</p><p>我们定义一个哑元节点 <code>dummyHead</code> ，再定义两个指针 <code>pre</code> 和 <code>end</code> ，这两个指针初始都指向哑元节点，<code>pre</code> 指针作用是需要翻转的链表的上一个节点，便于反转后将其连接起来，<code>end</code> 指针指向每次需要翻转的链表的尾节点。</p><p>接下来就是循环，循环条件就是 <code>end</code> 后面还有元素的时候继续。</p><p>循环内容：</p><ul><li><code>end</code>首先向后移动 <code>K</code> 个位置，如果 <code>end</code> 为空则转置完毕</li><li>然后找到需要转置链表的头，定义指针 <code>start</code> ，此指针的值就是 <code>pre</code> 指针的下一个节点</li><li>接下来保存 <code>end</code>后面的节点，便于转置后重新连接链表，记为 <code>next</code> 指针</li><li>接下来调用转置链表函数，将 <code>start</code> 指针传过去，不过在此之前要先将链表断开，方便转置函数操作</li><li>转置完毕，函数返回值为转置后的头指针，将 <code>pre</code> 指针的下一个元素赋值为此结果，这样就将前面连接起来了</li><li>转置前 <code>end</code> 为尾部指针，<code>start</code> 为头部指针，转置后正好反过来，连接后半部分就是 <code>start.next = next</code></li><li>接下来为下一次转置做准备，<code>pre = end = start</code></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseKGroup</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummyNode</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>, head);<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> dummyNode, end = dummyNode;<br>    <span class="hljs-keyword">while</span> (end.next != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; end != <span class="hljs-literal">null</span> &amp;&amp; i &lt; k; i++) end = end.next;<br>        <span class="hljs-keyword">if</span>(end == <span class="hljs-literal">null</span>) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> pre.next;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> end.next;<br>        end.next = <span class="hljs-literal">null</span>;<br>        pre.next = reverse(start);<br>        start.next = next;<br>        pre = start;<br>        end = start;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummyNode.next;<br>&#125;<br><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverse</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>, cur = head;<br>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> cur.next;<br>        cur.next = pre;<br>        pre = cur;<br>        cur = next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pre;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="/posts/23481/image-20210406214400887.png"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-142</title>
    <link href="/posts/63466.html"/>
    <url>/posts/63466.html</url>
    
    <content type="html"><![CDATA[<h1 id="142-环形链表II"><a href="#142-环形链表II" class="headerlink" title="142. 环形链表II"></a>142. 环形链表II</h1><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 <code>null</code>。</p><p>为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。  如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意，<code>pos</code> 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</strong></p><p><strong>说明：</strong>不允许修改给定的链表。</p><p><strong>进阶：</strong></p><ul><li>你是否可以使用 <code>O(1)</code> 空间解决此题？</li></ul><span id="more"></span><p><strong>示例 1：</strong></p><p><img src="/posts/63466/circularlinkedlist.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [3,2,0,-4], pos = 1<br>输出：返回索引为 1 的链表节点<br>解释：链表中有一个环，其尾部连接到第二个节点。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="/posts/63466/circularlinkedlist_test2.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [1,2], pos = 0<br>输出：返回索引为 0 的链表节点<br>解释：链表中有一个环，其尾部连接到第一个节点。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src="/posts/63466/circularlinkedlist_test3.png"></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">head</span> = [<span class="hljs-number">1</span>], <span class="hljs-attr">pos</span> = -<span class="hljs-number">1</span><br>输出：返回 <span class="hljs-literal">null</span><br>解释：链表中没有环。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围在范围 <code>[0, 10^4]</code> 内</li><li><code>-10^5 &lt;= Node.val &lt;= 10^5</code></li><li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>死记硬背吧，数学知识，找到快慢指针碰头的地方之后，头指针和慢指针一起一步一步走下去，第一次碰头的地点就是环的入口。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">detectCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head, slow = head, ptr = head;<br>    <span class="hljs-keyword">while</span> (fast != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span>(fast.next == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">else</span> &#123;<br>            fast = fast.next.next;<br>        &#125;<br>        slow = slow.next;<br>        <span class="hljs-keyword">if</span>(fast == slow) &#123;<br>            <span class="hljs-keyword">while</span> (ptr != slow) &#123;<br>                ptr = ptr.next;<br>                slow = slow.next;<br>            &#125;<br>            <span class="hljs-keyword">return</span> ptr;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="/posts/63466/image-20210406192917397.png"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-141</title>
    <link href="/posts/63146.html"/>
    <url>/posts/63146.html</url>
    
    <content type="html"><![CDATA[<h1 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a>141. 环形链表</h1><p>给定一个链表，判断链表中是否有环。</p><p>如果链表中有某个节点，可以通过连续跟踪 <code>next</code> 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 <code>pos</code> 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 <code>pos</code> 是 <code>-1</code>，则在该链表中没有环。<strong>注意：<code>pos</code> 不作为参数进行传递</strong>，仅仅是为了标识链表的实际情况。</p><p>如果链表中存在环，则返回 <code>true</code> 。 否则，返回 <code>false</code> 。</p><span id="more"></span><p><strong>进阶：</strong></p><p>你能用 <em>O(1)</em> （即，常量）内存解决此问题吗？</p><p><strong>示例 1：</strong></p><p><img src="/posts/63146/circularlinkedlist.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [3,2,0,-4], pos = 1<br>输出：<span class="hljs-literal">true</span><br>解释：链表中有一个环，其尾部连接到第二个节点。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="/posts/63146/circularlinkedlist_test2.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [1,2], pos = 0<br>输出：<span class="hljs-literal">true</span><br>解释：链表中有一个环，其尾部连接到第一个节点。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src="/posts/63146/circularlinkedlist_test3.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">输入：<span class="hljs-built_in">head</span> = [1], pos = -1<br>输出：<span class="hljs-literal">false</span><br>解释：链表中没有环。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围是 <code>[0, 10^4]</code></li><li><code>-10^5 &lt;= Node.val &lt;= 10^5</code></li><li><code>pos</code> 为 <code>-1</code> 或者链表中的一个 <strong>有效索引</strong> 。</li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>经典题目，快慢指针解决。</p><p>定义两个指针 <code>fast</code> 和 <code>slow</code> ，一个走两步，一个走一步，如果有环总会相遇。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasCycle</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">fast</span> <span class="hljs-operator">=</span> head.next, slow = head;<br>    <span class="hljs-keyword">while</span> (fast != slow) &#123;<br>        <span class="hljs-keyword">if</span>(fast == <span class="hljs-literal">null</span> || fast.next == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        slow = slow.next;<br>        fast = fast.next.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="/posts/63146/image-20210406185802465.png"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-24</title>
    <link href="/posts/39800.html"/>
    <url>/posts/39800.html</url>
    
    <content type="html"><![CDATA[<h1 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a>24. 两两交换链表中的节点</h1><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。</p><span id="more"></span><p><strong>示例 1：</strong></p><p><img src="/posts/39800/swap_ex1.jpg"></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：head = [<span class="hljs-number">1,2,3,4</span>]<br>输出：[<span class="hljs-number">2,1,4,3</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[]</span><br>输出：<span class="hljs-comment">[]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1]</span><br>输出：<span class="hljs-comment">[1]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目在范围 <code>[0, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 100</code></li></ul><p><strong>进阶：</strong>你能在不修改链表节点值的情况下解决这个问题吗?（也就是说，仅修改节点本身。）</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>两种解法，迭代和递归：</p><p>迭代：</p><p>定义三个指针，一个 <code>pre</code> 表示前一个节点，一个 <code>cur</code> 表示后一个节点，一个 <code>tmp</code> 表示转换后临时指向后一个节点的指针。</p><p>首先创建一个空的头节点 <code>dummyHead</code> 便于操作，初始将 <code>tmp</code> 指向 <code>dummyHead</code> ，循环结束条件即为 <code>tmp.next == null || tmp.next.next == null</code> 。</p><p>循环体内部只需进行如下操作即可：</p><ul><li><code>pre</code> 的下一个为 <code>cur</code> 的下一个</li><li><code>cur</code> 的下一个为 <code>pre</code></li><li><code>tmp</code> 的下一个为 <code>cur</code></li><li>最后将 <code>tmp</code> 赋值为新的后一个结点</li></ul><p>递归：</p><p>结束条件为： <code>head</code> 为空或者 <code>head.next</code> 为空，此时要么只有一个节点，要么没有节点，无法再交换。</p><p>如果有两个节点那么当前的 <code>head</code> 为前一个节点，<code>head.next</code> 为后一个节点，交换这两个节点即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>迭代</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">swapPairs</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummyHead</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>, head);<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> dummyHead;<br>    <span class="hljs-keyword">while</span> (tmp.next != <span class="hljs-literal">null</span> &amp;&amp; tmp.next.next != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> tmp.next, cur = pre.next;<br>        pre.next = cur.next;<br>        cur.next = pre;<br>        tmp.next = cur;<br>        tmp = pre;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummyHead.next;<br>&#125;<br></code></pre></td></tr></table></figure><p>递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">swapPairs</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">newHead</span> <span class="hljs-operator">=</span> head.next;<br>    head.next = swapPairs(newHead.next);<br>    newHead.next = head;<br>    <span class="hljs-keyword">return</span> newHead;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>迭代</p><p><img src="/posts/39800/image-20210406120438831.png"></p><p>递归</p><p><img src="/posts/39800/image-20210406120458336.png"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
      <tag>递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode-206</title>
    <link href="/posts/62489.html"/>
    <url>/posts/62489.html</url>
    
    <content type="html"><![CDATA[<h1 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a>206. 反转链表</h1><p>反转一个单链表。</p><p><strong>示例:</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">输入: <span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;NULL<br>输出: <span class="hljs-number">5</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">1</span>-&gt;NULL<br></code></pre></td></tr></table></figure><p><strong>进阶:</strong><br>你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</p><span id="more"></span><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>迭代方式：</p><ul><li>定义三个指针，<em>pre</em> 、 <em>cur</em> 和 <em>next</em>，<em>pre</em> 为上一个元素，<em>cur</em> 为当前操作元素，<em>next</em> 为下一个元素。</li><li>每次使 <em>cur</em> 指向 <em>pre</em> ，即可实现一次翻转。</li><li>然后 <em>pre</em> 移动为 <em>cur</em>， <em>cur</em> 移动为 <em>next</em>。</li><li>最后当 <em>cur</em> 为 <code>null</code> 时返回 <em>pre</em>。</li></ul><p>递归方式：</p><ul><li>使用递归函数，一直递归到链表的最后一个结点，该结点就是反转后的头结点，记作 <em>ret</em>。</li><li>此后，每次函数在返回的过程中，让当前结点的下一个结点的<em>next</em>指针指向当前节点。</li><li>同时让当前结点的 <em>next</em>指针指向 <code>null</code> ，从而实现从链表尾部开始的局部反转。</li><li>当递归函数全部出栈后，链表反转完成。</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>迭代方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>, cur = head;<br>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> cur.next;<br>        cur.next = pre;<br>        pre = cur;<br>        cur = next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pre;<br>&#125;<br></code></pre></td></tr></table></figure><p>递归方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> reverseList(head.next);<br>    head.next.next = head;<br>    head.next = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> cur;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>迭代方式：</p><p><img src="/posts/62489/image-20210405225642012.png"></p><p>递归方式：</p><p><img src="/posts/62489/image-20210405225721956.png"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
      <tag>递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 830</title>
    <link href="/posts/43195.html"/>
    <url>/posts/43195.html</url>
    
    <content type="html"><![CDATA[<h1 id="830-较大分组的位置"><a href="#830-较大分组的位置" class="headerlink" title="830. 较大分组的位置"></a>830. 较大分组的位置</h1><p>在一个由小写字母构成的字符串 <code>s</code> 中，包含由一些连续的相同字符所构成的分组。</p><p>例如，在字符串 <code>s = &quot;abbxxxxzyy&quot;</code> 中，就含有 <code>&quot;a&quot;</code>, <code>&quot;bb&quot;</code>, <code>&quot;xxxx&quot;</code>, <code>&quot;z&quot;</code> 和 <code>&quot;yy&quot;</code> 这样的一些分组。</p><p>分组可以用区间 <code>[start, end]</code> 表示，其中 <code>start</code> 和 <code>end</code> 分别表示该分组的起始和终止位置的下标。上例中的 <code>&quot;xxxx&quot;</code> 分组用区间表示为 <code>[3,6]</code> 。</p><p>我们称所有包含大于或等于三个连续字符的分组为 <strong>较大分组</strong> 。</p><p>找到每一个 <strong>较大分组</strong> 的区间，<strong>按起始位置下标递增顺序排序后</strong>，返回结果。</p><span id="more"></span><p><strong>示例 1：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：s = <span class="hljs-string">&quot;abbxxxxzzy&quot;</span><br>输出：<span class="hljs-string">[[3,6]]</span><br>解释：<span class="hljs-string">&quot;xxxx&quot;</span> 是一个起始于 <span class="hljs-number">3</span> 且终止于 <span class="hljs-number">6</span> 的较大分组。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入：s = <span class="hljs-string">&quot;abc&quot;</span><br>输出：[]<br>解释：<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span> 和 <span class="hljs-string">&quot;c&quot;</span> 均不是符合要求的较大分组。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：s = <span class="hljs-string">&quot;abcdddeeeeaabbbcd&quot;</span><br>输出：<span class="hljs-string">[[3,5],[6,9],[12,14]]</span><br>解释：较大分组为 <span class="hljs-string">&quot;ddd&quot;</span>, <span class="hljs-string">&quot;eeee&quot;</span> 和 <span class="hljs-string">&quot;bbb&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;aba&quot;</span><br>输出：[]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 仅含小写英文字母</li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>遍历数组，当下标为 <code>length - 1</code> 或者 下一个和当前字符不一样时进行统计，相同则计数器加一。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">largeGroupPositions</span><span class="hljs-params">(String s)</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">//计数器</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>        <span class="hljs-comment">//到了最后一个字符或者当前字符和下一个字符不一样，则重置计数器，否则计数加一</span><br>        <span class="hljs-keyword">if</span> (i == s.length() - <span class="hljs-number">1</span> || s.charAt(i) != s.charAt(i + <span class="hljs-number">1</span>)) &#123;<br>            <span class="hljs-comment">//数量大于等于三才添加进返回值</span><br>            <span class="hljs-keyword">if</span>(num &gt;= <span class="hljs-number">3</span>) &#123;<br>                ans.add(Arrays.asList(i - num + <span class="hljs-number">1</span>, i));<br>            &#125;<br>            <span class="hljs-comment">//重置</span><br>            num = <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            num++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="/posts/43195/image-20210105224219903.png"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 15</title>
    <link href="/posts/26664.html"/>
    <url>/posts/26664.html</url>
    
    <content type="html"><![CDATA[<h1 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a>15. 三数之和</h1><p>给你一个包含 <em>n</em> 个整数的数组 <code>nums</code>，判断 <code>nums</code> 中是否存在三个元素 <em>a，b，c ，</em>使得 <em>a + b + c &#x3D;</em> 0 ？请你找出所有满足条件且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><p><strong>示例：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">给定数组 nums = <span class="hljs-comment">[-1, 0, 1, 2, -1, -4]</span>，<br><br>满足要求的三元组集合为：<br><span class="hljs-comment">[</span><br><span class="hljs-comment">  <span class="hljs-comment">[-1, 0, 1]</span>,</span><br><span class="hljs-comment">  <span class="hljs-comment">[-1, -1, 2]</span></span><br><span class="hljs-comment">]</span><br></code></pre></td></tr></table></figure><span id="more"></span><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>和两数之和很像，不过这又加了一个数，两数之和使用的哈希表，这里用双指针。</p><p>思路：</p><ol><li>如果数组为 <code>null</code> 或者数组元素少于 <code>3</code> 个，返回空集。</li><li>对数组排序。</li><li>遍历排序后的数组：<ul><li>如果 <code>nums[i] &gt; 0</code> 返回结果，因为左指针在 <code>nums[i]</code> 右面，三数之和一定大于零。</li><li>如果 <code>nums[i] == nums[i+1]</code> ，则跳过这次结果，因为重复了。</li><li>定义左指针：<code>left = i+1</code>，右指针：<code>right = nums.length - 1</code>，当 <code>left &lt; right</code> 时，循环：<ul><li>当 <code>nums[i] + nums[left] + nums[right] == 0</code> 时，添加结果，然后去除左右指针重复元素，左右指针再各移一位。</li><li>当 <code>nums[i] + nums[left] + nums[right] &gt; 0</code> 时，移动右指针。</li><li>当 <code>nums[i] + nums[left] + nums[right] &lt; 0</code> 时，移动左指针。</li></ul></li></ul></li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">threeSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">//数组为空或者元素小于3返回空集</span><br>    <span class="hljs-keyword">if</span> (nums == <span class="hljs-literal">null</span> || nums.length &lt; <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> ans;<br>    <span class="hljs-comment">//排序</span><br>    Arrays.sort(nums);<br>    <span class="hljs-comment">//遍历</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-comment">//nums[i]大于零一定没解了</span><br>        <span class="hljs-keyword">if</span> (nums[i] &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> ans;<br>        <span class="hljs-comment">//当前元素和下一个元素一样，跳过本次结果</span><br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i - <span class="hljs-number">1</span>]) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">//定义左指针和右指针</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>, right = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-comment">//找到一个解</span><br>            <span class="hljs-keyword">if</span> (nums[i] + nums[left] + nums[right] == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">//添加</span><br>                ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>                list.add(nums[i]);<br>                list.add(nums[left]);<br>                list.add(nums[right]);<br>                ans.add(list);<br>                <span class="hljs-comment">//去除左右指针指向的重复元素</span><br>                <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="hljs-number">1</span>]) left++;<br>                <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="hljs-number">1</span>]) right--;<br>                <span class="hljs-comment">//最后要各自移动一位</span><br>                left++;<br>                right--;<br>            <span class="hljs-comment">//元素大了，右指针向左</span><br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[i] + nums[left] + nums[right] &gt; <span class="hljs-number">0</span>) &#123;<br>                right--;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//元素小了，左指针向右</span><br>                left++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="/posts/26664/image-20210103213542961.png"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 70</title>
    <link href="/posts/52203.html"/>
    <url>/posts/52203.html</url>
    
    <content type="html"><![CDATA[<h1 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a>70. 爬楼梯</h1><p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>注意：</strong>给定 <em>n</em> 是一个正整数。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入： 2<br>输出： 2<br>解释： 有两种方法可以爬到楼顶。<br>1. <span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶<br>2. <span class="hljs-number"> 2 </span>阶<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入： 3<br>输出： 3<br>解释： 有三种方法可以爬到楼顶。<br>1. <span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 1 </span>阶<br>2. <span class="hljs-number"> 1 </span>阶 +<span class="hljs-number"> 2 </span>阶<br>3. <span class="hljs-number"> 2 </span>阶 +<span class="hljs-number"> 1 </span>阶<br></code></pre></td></tr></table></figure><span id="more"></span><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>通过分析得出，每一层的可能就是上一层和上上层可能之和，可得出公式：<code>f(n) = f(n-1)+f(n-2)</code> ，其实就是斐波那契数列。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">climbStairs</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-comment">//前两层n种</span><br>    <span class="hljs-keyword">if</span>(n &lt;= <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">return</span> n;<br>    <span class="hljs-comment">//当前层，上一层，上上层</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">cut</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, pre = <span class="hljs-number">2</span>, prePre = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-comment">//当前层等于上一层加上上层</span><br>        cut = pre + prePre;<br>        <span class="hljs-comment">//为下一次做准备，上上层等于上一层</span><br>        prePre = pre;<br>        <span class="hljs-comment">//上一层等于当前层</span><br>        pre = cut;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cut;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="/posts/52203/image-20210102231011161.png"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 283</title>
    <link href="/posts/39900.html"/>
    <url>/posts/39900.html</url>
    
    <content type="html"><![CDATA[<h1 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a>283. 移动零</h1><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>示例:</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入: <span class="hljs-string">[0,1,0,3,12]</span><br>输出: <span class="hljs-string">[1,3,12,0,0]</span><br></code></pre></td></tr></table></figure><p><strong>说明</strong>:</p><ol><li>必须在原数组上操作，不能拷贝额外的数组。</li><li>尽量减少操作次数。</li></ol><span id="more"></span><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>使用双指针</p><ol><li>一个指针从头到尾扫描数组，如果当前元素不为 <code>0</code> 就将当前元素复制到另一个指针，当前元素置零</li><li>另一个指针从下标为 <code>0</code> 开始，每次另一个指针赋值后，此指针加一</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveZeroes</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    <span class="hljs-comment">//第二个指针</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//i为第一个指针</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-comment">//数组元素不为0，则进行赋值</span><br>        <span class="hljs-keyword">if</span>(nums[i] != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//这里进行一点优化，数组第一个元素不用交换</span><br>            <span class="hljs-keyword">if</span>(i &gt; j) &#123;<br>                nums[j] = nums[i];<br>                nums[i] = <span class="hljs-number">0</span>;<br>            &#125;<br>            j++;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="/posts/39900/image-20210101175211456.png"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 11</title>
    <link href="/posts/43817.html"/>
    <url>/posts/43817.html</url>
    
    <content type="html"><![CDATA[<h1 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a>11. 盛最多水的容器</h1><p>给你 <code>n</code> 个非负整数 <code>a1，a2，...，a``n</code>，每个数代表坐标中的一个点 <code>(i, ai)</code> 。在坐标内画 <code>n</code> 条垂直线，垂直线 <code>i</code> 的两个端点分别为 <code>(i, ai)</code> 和 <code>(i, 0)</code> 。找出其中的两条线，使得它们与 <code>x</code> 轴共同构成的容器可以容纳最多的水。</p><p><strong>说明：</strong>你不能倾斜容器。</p><span id="more"></span><p><img src="/posts/43817/question_11.jpg"></p><p><strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：[<span class="hljs-number">1,8,6,2</span>,<span class="hljs-number">5,4,8,3</span>,<span class="hljs-number">7</span>]<br>输出：<span class="hljs-number">49</span> <br>解释：图中垂直线代表输入数组 [<span class="hljs-number">1,8,6,2</span>,<span class="hljs-number">5,4,8,3</span>,<span class="hljs-number">7</span>]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 <span class="hljs-number">49</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">输入：height = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：height = <span class="hljs-string">[4,3,2,1,4]</span><br>输出：<span class="hljs-number">16</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">输入：height = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n = height.length</code></li><li><code>2 &lt;= n &lt;= 3 * 10e4</code></li><li><code>0 &lt;= height[i] &lt;= 3 * 10e4</code></li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>使用双指针找到最大面积即可（没啥道理，就是死记）</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxArea</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>        <span class="hljs-comment">//定义左右指针</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = height.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//最大面积</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">maxArea</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>            <span class="hljs-comment">//较小的是高，距离是宽</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">area</span> <span class="hljs-operator">=</span> (right - left) * Math.min(height[left], height[right]);<br>            <span class="hljs-comment">//更新最大面积</span><br>            <span class="hljs-keyword">if</span> (area &gt; maxArea) &#123;<br>                maxArea = area;<br>            &#125;<br>            <span class="hljs-comment">//较小值的那个指针向前一步（注意，Java三元表达式返回值必须要接收，不然报错）</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> height[left] &lt; height[right] ? left++ : right--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxArea;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="/posts/43817/image-20201230200719927.png"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 387</title>
    <link href="/posts/39052.html"/>
    <url>/posts/39052.html</url>
    
    <content type="html"><![CDATA[<h1 id="387-字符串中的第一个唯一字符"><a href="#387-字符串中的第一个唯一字符" class="headerlink" title="387. 字符串中的第一个唯一字符"></a>387. 字符串中的第一个唯一字符</h1><p>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</p><p><strong>示例：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;leetcode&quot;</span><br>返回 <span class="hljs-number">0</span><br><br><span class="hljs-attribute">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;loveleetcode&quot;</span><br>返回 <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong>你可以假定该字符串只包含小写字母。</p><span id="more"></span><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>既然题目已经假定了只有小写字母，那代码就按照小写字母来写，先把字符串所有字符数量存到数组里，再遍历字符串，找到数组存储数量为 1 的字符，再返回下标即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">firstUniqChar</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">//假定只有小写字母，所以只申请26个空间</span><br>        <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-comment">//先把所有字符数量存到数组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            arr[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        &#125;<br>        <span class="hljs-comment">//挨个判断当前字符数量是不是1，是1则找到了，返回下标</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            <span class="hljs-keyword">if</span>(arr[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> i;<br>        &#125;<br>        <span class="hljs-comment">//没找到，返回-1</span><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="/posts/39052/image-20201223230638423.png"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IntelliJ IDEA更新Maven远程仓库索引</title>
    <link href="/posts/60887.html"/>
    <url>/posts/60887.html</url>
    
    <content type="html"><![CDATA[<h1 id="IntelliJ-IDEA更新Maven远程仓库索引"><a href="#IntelliJ-IDEA更新Maven远程仓库索引" class="headerlink" title="IntelliJ IDEA更新Maven远程仓库索引"></a>IntelliJ IDEA更新Maven远程仓库索引</h1><p>​因为某些原因，在 <code>IDEA</code> 下载 <code>Maven</code> 索引总是特别慢，有时候等待它下载好几个小时，然后突然抽风下载失败，再下载又要重新下了，所以这里介绍从远程下载索引到本地更新的方法。</p><p>​本文默认你已经在 <code>IDEA</code> 配置好了 <code>Maven</code> 和 <code>tomcat</code> 环境，并且在 <code>IntelliJ IDEA</code> 已经关联了配置好的 <code>Maven</code>。</p><span id="more"></span><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>​<code>IDEA</code> 更新索引默认从中央仓库下载，如果在国内，下载非常慢。配置了阿里云镜像，就会从配置的镜像根目录 <code>/.index/</code> 找索引文件，但是阿里云并没有提供索引服务，所以如果配置了阿里云镜像，再更新索引会报错。</p><p>​所以我们搭建 <code>tomcat</code> 本地服务器，再把本地服务器伪装成阿里云镜像服务器，将索引文件放到本地服务器，再从中央仓库下载索引文件放到服务器里，这样 <code>IDEA</code> 就会从本地服务器下载索引来更新。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li><p>打开 <code>Maven</code> 的配置文件 ：<code>Maven根目录/conf/settings.xml</code> ，先把自己添加的所有镜像注释，然后添加如下镜像，后面我们的 <code>tomcat</code> 本地服务器要伪装成这个镜像服务器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>aliyunmaven<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>*<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>阿里云公共仓库<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.aliyun.com/repository/public<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意是 <strong>http</strong> 而不是 <strong>https</strong> ！！！</p><p>因为我们搭建 <code>tomcat</code>  服务器默认是 <code>http</code> 服务。</p></li><li><p>打开 <code>tomcat</code> 的服务器配置文件：<code>tomcat根目录/conf/server.xml</code> ，找到这一段：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;Connector <span class="hljs-attribute">port</span>=<span class="hljs-string">&quot;8080&quot;</span> <span class="hljs-attribute">protocol</span>=<span class="hljs-string">&quot;HTTP/1.1&quot;</span><br>           <span class="hljs-attribute">connectionTimeout</span>=<span class="hljs-string">&quot;60000&quot;</span><br>           <span class="hljs-attribute">redirectPort</span>=<span class="hljs-string">&quot;8443&quot;</span> <span class="hljs-attribute">acceptCount</span>=<span class="hljs-string">&quot;500&quot;</span> <span class="hljs-attribute">maxThreads</span>=<span class="hljs-string">&quot;400&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>将端口 <strong>8080</strong> 改为 <strong>80</strong> ，<code>tomcat</code> 服务启动以后，访问路径是 <code>127.0.0.1:8080</code>，<code>http</code> 默认端口是 <code>80</code> ，所以先改 <code>tomcat</code> 端口为80，这样浏览器输入<code>127.0.0.1</code> 就是 <code>tomcat</code> 主页</p></li><li><p>手动从中央仓库下载索引，需要下载两个文件：<a href="https://repo1.maven.org/maven2/.index/nexus-maven-repository-index.properties">nexus-maven-repository-index.properties</a> 和 <a href="https://repo1.maven.org/maven2/.index/nexus-maven-repository-index.gz">nexus-maven-repository-index.gz</a> 。这里有个小坑，从谷歌浏览器直接另存为第一个文件，会自动加 <code>.txt</code> 后缀，注意去除。</p></li><li><p>在 <code>tomcat根目录/webapps/ROOT/</code> 下 创建文件夹 <code>/repository/public/.index/</code>  ，将下载好的文件移动到 <code>tomcat根目录/webapps/ROOT/repository/public/.index/</code> 下，<code>tomcat</code> 主页对应 <code>tomcat</code> 文件夹中的 <code>ROOT</code> 文件夹，因此，我们在 <code>ROOT</code> 文件夹里加文件，就能通过 <code>127.0.0.1/文件夹名</code> 下载。 </p></li><li><p>使用管理员权限修改 <code>host</code> 文件：<code>C:/Windows/System32/drivers/etc/hosts</code> ，在最后添加一行：<code>127.0.0.1 maven.aliyun.com</code> ，使访问<code>maven.aliyun.com</code> 映射到 <code>127.0.0.1</code>，计算机是先查 <code>host</code> 再查 <code>dns</code> 的，因此，修改 <code>host</code> 文件，把阿里云映射到本地，这样，访问 <code>maven.aliyun.com</code> 时，系统就自动跳到 <code>127.0.0.1</code> 。</p></li><li><p>启动 <code>tomcat</code> ，在 <code>Windows</code> 系统下双击 <code>tomcat根目录/bin/startup.bat</code> 即可，启动时可能会报找不到 <code>jdk</code> 或者80端口占用等错误，百度一下自行解决，这里不再赘述。启动完成后建议浏览器访问 <code>http://maven.aliyun.com/repository/central/.index/nexus-maven-repository-index.properties</code>，看看是不是正常访问。</p></li><li><p>打开 <code>IDEA</code> ，然后打开 <code>File -&gt; Settings</code> 或者快捷键 <code>Ctrl + Alt + S</code> 打开设置，找到 <code>Build,Execution,Deployment -&gt; Build Tools -&gt; Maven -&gt; Respositories</code> ，然后点击 <code>https://repo.maven.apache.org/maven2</code> 再点击 <code>Update</code> 按钮进行更新，这时候千万不能关闭对话框，否则会导致更新失败，<code>IDEA</code> 右下角会有更新进度条，等进度条消失就更新完毕啦。</p></li><li><p>更新完成后我们要恢复一些配置文件：</p><ul><li>关闭 <code>tomcat</code> 服务器，修改 <code>server.xml</code> 配置文件，将 80 端口再改为8080端口。</li><li>删除 <code>ROOT</code> 目录下的文件夹。</li><li>删除 <code>hosts</code> 最后一行我们添加的映射。</li><li>将 <code>Maven</code> 配置文件中 <code>http</code> 再改为 <code>https</code>。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>IntelliJ IDEA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 217</title>
    <link href="/posts/2267.html"/>
    <url>/posts/2267.html</url>
    
    <content type="html"><![CDATA[<h1 id="217-存在重复元素"><a href="#217-存在重复元素" class="headerlink" title="217. 存在重复元素"></a>217. 存在重复元素</h1><p>给定一个整数数组，判断是否存在重复元素。</p><p>如果任意一值在数组中出现至少两次，函数返回 <code>true</code> 。如果数组中每个元素都不相同，则返回 <code>false</code> 。</p><p><strong>示例 1:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [1,2,3,1]</span><br><span class="hljs-section">输出: true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: [1,2,3,4]</span><br><span class="hljs-section">输出: false</span><br></code></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入: [<span class="hljs-number">1,1,1,3</span>,<span class="hljs-number">3,4,3,2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>]<br>输出: true<br></code></pre></td></tr></table></figure><span id="more"></span><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>使用哈希表添加元素，当添加不进去元素时说明已经存在。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsDuplicate</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>        <span class="hljs-comment">//哈希表，使用Map会超时</span><br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x: nums) &#123;<br>            <span class="hljs-comment">//添加失败说明存在重复元素，返回true</span><br>            <span class="hljs-keyword">if</span>(!set.add(x)) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="/posts/2267/image-20201213221120740.png"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 860</title>
    <link href="/posts/63672.html"/>
    <url>/posts/63672.html</url>
    
    <content type="html"><![CDATA[<h1 id="860-柠檬水找零"><a href="#860-柠檬水找零" class="headerlink" title="860. 柠檬水找零"></a>860. 柠檬水找零</h1><p>在柠檬水摊上，每一杯柠檬水的售价为 <code>5</code> 美元。</p><p>顾客排队购买你的产品，（按账单 <code>bills</code> 支付的顺序）一次购买一杯。</p><p>每位顾客只买一杯柠檬水，然后向你付 <code>5</code> 美元、<code>10</code> 美元或 <code>20</code> 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 <code>5</code> 美元。</p><p>注意，一开始你手头没有任何零钱。</p><p>如果你能给每位顾客正确找零，返回 <code>true</code> ，否则返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：[5,5,5,10,20]<br>输出：true<br>解释：<br>前<span class="hljs-number"> 3 </span>位顾客那里，我们按顺序收取<span class="hljs-number"> 3 </span>张<span class="hljs-number"> 5 </span>美元的钞票。<br>第<span class="hljs-number"> 4 </span>位顾客那里，我们收取一张<span class="hljs-number"> 10 </span>美元的钞票，并返还<span class="hljs-number"> 5 </span>美元。<br>第<span class="hljs-number"> 5 </span>位顾客那里，我们找还一张<span class="hljs-number"> 10 </span>美元的钞票和一张<span class="hljs-number"> 5 </span>美元的钞票。<br>由于所有客户都得到了正确的找零，所以我们输出 true。<br></code></pre></td></tr></table></figure><span id="more"></span><p><strong>示例 2：</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入：[<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入：[<span class="hljs-number">10</span>,<span class="hljs-number">10</span>]<br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：[5,5,10,10,20]<br>输出：false<br>解释：<br>前<span class="hljs-number"> 2 </span>位顾客那里，我们按顺序收取<span class="hljs-number"> 2 </span>张<span class="hljs-number"> 5 </span>美元的钞票。<br>对于接下来的<span class="hljs-number"> 2 </span>位顾客，我们收取一张<span class="hljs-number"> 10 </span>美元的钞票，然后返还<span class="hljs-number"> 5 </span>美元。<br>对于最后一位顾客，我们无法退回<span class="hljs-number"> 15 </span>美元，因为我们现在只有两张<span class="hljs-number"> 10 </span>美元的钞票。<br>由于不是每位顾客都得到了正确的找零，所以答案是 false。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= bills.length &lt;= 10000</code></li><li><code>bills[i]</code> 不是 <code>5</code> 就是 <code>10</code> 或是 <code>20</code></li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>分情况考虑：</p><ul><li><p>顾客给<code>5</code>美元：直接收下。</p></li><li><p>顾客给<code>10</code>美元：先看看自己有没有<code>5</code>美元的票子，如果有，则收下<code>10</code>美元递出<code>5</code>美元，没有则找不开。</p></li><li><p>顾客给<code>20</code>美元：分三种情况：</p><ol><li>有一张<code>10</code>美元和一张<code>5</code>美元，则收下<code>20</code>美元递出一张<code>10</code>美元和一张<code>15</code>美元。</li><li>有三张<code>5</code>美元，则收下<code>20</code>美元递出三张<code>5</code>美元。</li><li>找不开。</li></ol></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">lemonadeChange</span><span class="hljs-params">(<span class="hljs-type">int</span>[] bills)</span> &#123;<br>        <span class="hljs-comment">//记录5美元和10美元的数量，20美元不用记，找零也不用它</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">five</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, ten = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> bill : bills) &#123;<br>            <span class="hljs-keyword">if</span> (bill == <span class="hljs-number">5</span>) &#123;<br>                <span class="hljs-comment">//顾客给5美元，收下</span><br>                five++;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bill == <span class="hljs-number">10</span>) &#123;<br>                <span class="hljs-comment">//顾客给10美元，如果没5美元的了，找不了</span><br>                <span class="hljs-keyword">if</span> (five &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-comment">//手下10美元，找出5美元</span><br>                five--;<br>                ten++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">//顾客给20美元，只要没5美元的直接找不了</span><br>                <span class="hljs-keyword">if</span> (five &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-comment">//优先给顾客找个10美元+5美元的组合</span><br>                <span class="hljs-keyword">if</span> (ten &gt; <span class="hljs-number">0</span>) &#123;<br>                    ten--;<br>                    five--;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">//找3个五美元</span><br>                    <span class="hljs-keyword">if</span> (five &gt; <span class="hljs-number">2</span>) five -= <span class="hljs-number">3</span>;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="/posts/63672/image-20201210223714916.png"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>贪心算法</tag>
      
      <tag>模拟</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 204</title>
    <link href="/posts/39322.html"/>
    <url>/posts/39322.html</url>
    
    <content type="html"><![CDATA[<h1 id="204-质数计数"><a href="#204-质数计数" class="headerlink" title="204. 质数计数"></a>204. 质数计数</h1><p>统计所有小于非负整数 <em><code>n</code></em> 的质数的数量。</p><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：n = 10<br>输出：4<br>解释：小于<span class="hljs-number"> 10 </span>的质数一共有<span class="hljs-number"> 4 </span>个, 它们是 2, 3, 5,<span class="hljs-number"> 7 </span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：n <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><span id="more"></span><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 5 * 10E6 </code></li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>素数计数，属于经典题目了，方法有很多种，时间复杂度从高到低依次排列为：</p><ol><li>从<code>2 至 n</code>依次判断是否是素数</li><li>从<code>2 至 n/2</code>依次判断是否是素数</li><li>从<code>2 至 sqrt(n)</code>依次判断是否是素数</li><li>使用埃氏筛法</li><li>使用欧式筛法</li></ol><p>这里使用<strong>埃氏筛法</strong>来做</p><p>埃氏筛法思路：从2开始先将2的倍数全部剔除，然后是3的倍数，5的倍数……最后留下来的都是素数</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">countPrimes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">//由于我们只关心数量，不关心具体的值，所以定义成boolean就够用了</span><br>        <span class="hljs-type">boolean</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[n];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-comment">//反逻辑，boolean数组默认初始化为false，把false当成是素数</span><br>            <span class="hljs-keyword">if</span> (!a[i]) &#123;<br>                ans++;<br>                <span class="hljs-comment">//防止int在运算过程中溢出</span><br>                <span class="hljs-keyword">if</span> ((<span class="hljs-type">long</span>) i * i &lt; n)<br>                    <span class="hljs-comment">//将i的所有倍数置为true，即不是素数</span><br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i * i; j &lt; n; j += i) &#123;<br>                        a[j] = <span class="hljs-literal">true</span>;<br>                    &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="/posts/39322/image-20201203230514318.png"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Leetcode 976</title>
    <link href="/posts/45674.html"/>
    <url>/posts/45674.html</url>
    
    <content type="html"><![CDATA[<h1 id="976-三角形的最大周长"><a href="#976-三角形的最大周长" class="headerlink" title="976. 三角形的最大周长"></a>976. 三角形的最大周长</h1><p>给定由一些正数（代表长度）组成的数组 <code>A</code>，返回由其中三个长度组成的、<strong>面积不为零</strong>的三角形的最大周长。</p><p>如果不能形成任何面积不为零的三角形，返回 <code>0</code>。</p><p><strong>示例 1：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">输入：<span class="hljs-selector-attr">[2,1,2]</span><br>输出：<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">输入：<span class="hljs-selector-attr">[1,2,1]</span><br>输出：<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">输入：<span class="hljs-selector-attr">[3,2,3,4]</span><br>输出：<span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">输入：<span class="hljs-selector-attr">[3,6,2,3]</span><br>输出：<span class="hljs-number">8</span><br></code></pre></td></tr></table></figure> <span id="more"></span><p><strong>提示：</strong></p><ol><li><code>3 &lt;= A.length &lt;= 10000</code></li><li><code>1 &lt;= A[i] &lt;= 10^6</code></li></ol><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>简单题，开心！！！先排序，从大到小找三角形最长边，然后剩下两条边尽量大就好。构成三角形的条件：两边之和大于第三边和两边之差小于第三边。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">largestPerimeter</span><span class="hljs-params">(<span class="hljs-type">int</span>[] A)</span> &#123;<br>    <span class="hljs-comment">//排序</span><br>    Arrays.sort(A);<br>    <span class="hljs-comment">//从大到小找</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> A.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">2</span>; i--)<br>        <span class="hljs-keyword">if</span> (A[i - <span class="hljs-number">2</span>] + A[i - <span class="hljs-number">1</span>] &gt; A[i])<br>            <span class="hljs-comment">//返回周长</span><br>            <span class="hljs-keyword">return</span> A[i - <span class="hljs-number">2</span>] + A[i - <span class="hljs-number">1</span>] + A[i];<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="/posts/45674/image-20201129184705544.png"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
      <tag>数学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1370</title>
    <link href="/posts/52201.html"/>
    <url>/posts/52201.html</url>
    
    <content type="html"><![CDATA[<h1 id="1370-上升下降字符串"><a href="#1370-上升下降字符串" class="headerlink" title="1370.  上升下降字符串"></a>1370.  上升下降字符串</h1><p>给你一个字符串 <code>s</code> ，请你根据下面的算法重新构造字符串：</p><ol><li>从 <code>s</code> 中选出 <strong>最小</strong> 的字符，将它 <strong>接在</strong> 结果字符串的后面。</li><li>从 <code>s</code> 剩余字符中选出 <strong>最小</strong> 的字符，且该字符比上一个添加的字符大，将它 <strong>接在</strong> 结果字符串后面。</li><li>重复步骤 2 ，直到你没法从 <code>s</code> 中选择字符。</li><li>从 <code>s</code> 中选出 <strong>最大</strong> 的字符，将它 <strong>接在</strong> 结果字符串的后面。</li><li>从 <code>s</code> 剩余字符中选出 <strong>最大</strong> 的字符，且该字符比上一个添加的字符小，将它 <strong>接在</strong> 结果字符串后面。</li><li>重复步骤 5 ，直到你没法从 <code>s</code> 中选择字符。</li><li>重复步骤 1 到 6 ，直到 <code>s</code> 中所有字符都已经被选过。</li></ol><p>在任何一步中，如果最小或者最大字符不止一个 ，你可以选择其中任意一个，并将其添加到结果字符串。</p><p>请你返回将 <code>s</code> 中字符重新排序后的 <strong>结果字符串</strong> 。</p><span id="more"></span><p><strong>示例 1：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;aaaabbbbcccc&quot;</span><br>输出：<span class="hljs-string">&quot;abccbaabccba&quot;</span><br>解释：第一轮的步骤 <span class="hljs-number">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">3</span> 后，结果字符串为 result <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span><br>第一轮的步骤 <span class="hljs-number">4</span>，<span class="hljs-number">5</span>，<span class="hljs-number">6</span> 后，结果字符串为 result <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abccba&quot;</span><br>第一轮结束，现在 s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;aabbcc&quot;</span> ，我们再次回到步骤 <span class="hljs-number">1</span><br>第二轮的步骤 <span class="hljs-number">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">3</span> 后，结果字符串为 result <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abccbaabc&quot;</span><br>第二轮的步骤 <span class="hljs-number">4</span>，<span class="hljs-number">5</span>，<span class="hljs-number">6</span> 后，结果字符串为 result <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abccbaabccba&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;rat&quot;</span><br>输出：<span class="hljs-string">&quot;art&quot;</span><br>解释：单词 <span class="hljs-string">&quot;rat&quot;</span> 在上述算法重排序以后变成 <span class="hljs-string">&quot;art&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;leetcode&quot;</span><br>输出：<span class="hljs-string">&quot;cdelotee&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ggggggg&quot;</span><br>输出：<span class="hljs-string">&quot;ggggggg&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">输入：s <span class="hljs-operator">=</span> <span class="hljs-string">&quot;spo&quot;</span><br>输出：<span class="hljs-string">&quot;ops&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 500</code></li><li><code>s</code> 只包含小写英文字母。</li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>题目意思为：按照字典序从低到高取一遍字母拼接到新字符串，再从高到低取一遍拼接到新字符串，重复上述操作，当把<code>s</code>所有字符取完时，返回重新拼接的字符串。</p><p>思路：字符串<code>s</code> 只包含26个英文字母，那我们可以创建26个桶，每个桶储存一个英文字母的数量，循环从桶里取字符：</p><ul><li>先从小到大遍历所有桶，桶里有字符就拼接到字符串最后。</li><li>再从大到小遍历所有桶，桶里有字符就拼接到字符串最后。</li><li>重复上述操作，当重新拼接的字符串等于<code>s</code>的长度时，拼接结束，返回拼接后的字符串。</li></ul><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">sortString</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">//创建26个桶</span><br>        <span class="hljs-type">int</span>[] bucket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">26</span>];<br>        <span class="hljs-comment">//字符放到桶里</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; s.length(); i++)<br>            bucket[s.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        <span class="hljs-comment">//重新拼接后的字符串</span><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-comment">//重新拼接的字符串等于s的长度时，拼接结束</span><br>        <span class="hljs-keyword">while</span> (sb.toString().length() != s.length()) &#123;<br>            <span class="hljs-comment">//从小到大遍历所有桶</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++)<br>                <span class="hljs-keyword">if</span>(bucket[i] &gt; <span class="hljs-number">0</span>) &#123;<br>                    sb.append((<span class="hljs-type">char</span>)(i + <span class="hljs-string">&#x27;a&#x27;</span>));<br>                    bucket[i]--;<br>                &#125;<br>            <span class="hljs-comment">//从大到小遍历所有桶</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">25</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>                <span class="hljs-keyword">if</span>(bucket[i] &gt; <span class="hljs-number">0</span>) sb.append((<span class="hljs-type">char</span>)(i + <span class="hljs-string">&#x27;a&#x27;</span>));<br>                bucket[i]--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h1><p><img src="/posts/52201/image-20201125184000260.png"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>排序</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1122</title>
    <link href="/posts/39626.html"/>
    <url>/posts/39626.html</url>
    
    <content type="html"><![CDATA[<h1 id="1122-数组的相对排序"><a href="#1122-数组的相对排序" class="headerlink" title="1122. 数组的相对排序"></a>1122. 数组的相对排序</h1><p>给你两个数组，<code>arr1</code> 和 <code>arr2</code>，</p><ul><li><code>arr2</code> 中的元素各不相同</li><li><code>arr2</code> 中的每个元素都出现在 <code>arr1</code> 中</li></ul><p>对<code>arr1</code>中的元素进行排序，使 <code>arr1</code> 中项的相对顺序和 <code>arr2</code> 中的相对顺序相同。未在 <code>arr2</code> 中出现过的元素需要按照升序放在 <code>arr1</code> 的末尾。</p><p><strong>示例：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：arr1 = [<span class="hljs-number">2,3,1,3</span>,<span class="hljs-number">2,4,6,7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">2</span>,<span class="hljs-number">19</span>], arr2 = [<span class="hljs-number">2,1,4,3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">6</span>]<br>输出：[<span class="hljs-number">2,2,2,1</span>,<span class="hljs-number">4,3,3,9</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">19</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>arr1.length, arr2.length &lt;= 1000</code></li><li><code>0 &lt;= arr1[i], arr2[i] &lt;= 1000</code></li><li><code>arr2</code> 中的元素 <code>arr2[i]</code> 各不相同</li><li><code>arr2</code> 中的每个元素 <code>arr2[i]</code> 都出现在 <code>arr1</code> 中</li></ul><span id="more"></span><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>对<code>arr1</code>进行自定义排序，<code>arr2</code>元素在前，其它元素在后。把<code>int</code>数组转成<code>List</code>再转回来挺麻烦的，直接使用<code>Java 8</code>新语法<code>stream + lambda</code>一行搞定</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] relativeSortArray(<span class="hljs-type">int</span>[] arr1, <span class="hljs-type">int</span>[] arr2) &#123;<br>    HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-comment">//map中保存每个元素和其对应的权重，权重小的排序在前面</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arr2.length; i++)<br>        map.put(arr2[i], i);<br>    <span class="hljs-comment">//无法对int数组进行自定义排序，所以需要先装箱，再自定义排序规则，最后转为int数组</span><br>    <span class="hljs-keyword">return</span> Arrays.stream(arr1).boxed().sorted((a, b) -&gt; &#123;<br>        <span class="hljs-comment">//两个数都在arr2中，根据权重决定谁在前</span><br>        <span class="hljs-keyword">if</span>(map.containsKey(a) &amp;&amp; map.containsKey(b))<br>            <span class="hljs-keyword">return</span> map.get(a) - map.get(b);<br>        <span class="hljs-comment">//只有a在arr2中，所以a一定在b前</span><br>        <span class="hljs-keyword">if</span>(map.containsKey(a)) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">//只有b在arr2中，所以a一定在b后</span><br>        <span class="hljs-keyword">if</span>(map.containsKey(b))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">//都不在，按照从小到大排序</span><br>        <span class="hljs-keyword">return</span> a - b;<br><br>    &#125;).mapToInt(Integer::intValue).toArray();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="/posts/39626/1.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 941</title>
    <link href="/posts/38953.html"/>
    <url>/posts/38953.html</url>
    
    <content type="html"><![CDATA[<h1 id="941-有效的山脉数组"><a href="#941-有效的山脉数组" class="headerlink" title="941. 有效的山脉数组"></a>941. 有效的山脉数组</h1><p>给定一个整数数组 <code>A</code>，如果它是有效的山脉数组就返回 <code>true</code>，否则返回 <code>false</code>。</p><p>让我们回顾一下，如果 A 满足下述条件，那么它是一个山脉数组：</p><ul><li><code>A.length &gt;= 3</code></li><li>在 <code>0 &lt; i &lt; A.length - 1</code> 条件下，存在 <code>i</code> 使得：<ul><li><code>A[0] &lt; A[1] &lt; ... A[i-1] &lt; A[i]</code></li><li><code>A[i] &gt; A[i+1] &gt; ... &gt; A[A.length - 1]</code></li></ul></li></ul><p><img src="/posts/38953/hint_valid_mountain_array.png"></p><p><strong>示例 1：</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入：[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入：[<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>]<br>输出：<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">输入：[<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br>输出：<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li><code>0 &lt;= A.length &lt;= 10000</code></li><li><code>0 &lt;= A[i] &lt;= 10000 </code></li></ol><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><ol><li><p>如果数组小于3，直接返回 <code>false</code></p></li><li><p>从最数组左边开始，要求每个元素都比前一个 <strong>严格递增</strong> </p></li><li><p>找到最高点之后，如果它是第一个或者最后一个元素，则不满足题意，直接返回<code>false</code></p></li><li><p>接着向右找，要求每一个元素都比前一个 <strong>严格递减</strong> ，如果直到最后一个元素都是如此，则返回 <code>true</code> ，否则返回 <code>false</code></p></li></ol><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">validMountainArray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] A)</span> &#123;<br>        <span class="hljs-comment">//如果数组小于3，直接返回false</span><br>        <span class="hljs-keyword">if</span>(A.length &lt; <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//从第一个元素开始从低到高依次严格增加</span><br>        <span class="hljs-keyword">while</span>(i+<span class="hljs-number">1</span> &lt; A.length &amp;&amp; A[i] &lt; A[i+<span class="hljs-number">1</span>])<br>            i++;<br>        <span class="hljs-comment">//找到了最高的一个元素，如果这个元素是第一个或者是最后一个，则不是山脉</span><br>        <span class="hljs-keyword">if</span>(i ==A.length - <span class="hljs-number">1</span> || i == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">//接着往后，依次严格递减</span><br>        <span class="hljs-keyword">while</span> (i+<span class="hljs-number">1</span> &lt; A.length &amp;&amp; A[i] &gt; A[i+<span class="hljs-number">1</span>])<br>            i++;<br>        <span class="hljs-comment">//如果到了最后一个元素俨然严格递减则为山脉数组</span><br>        <span class="hljs-keyword">return</span> i == A.length-<span class="hljs-number">1</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h1><p><img src="/posts/38953/1.JPG"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 1</title>
    <link href="/posts/26794.html"/>
    <url>/posts/26794.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h1><p>给定一个整数数组<code>nums</code>和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那 <strong>两个</strong> 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><p><strong>示例</strong>：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">给定 nums = <span class="hljs-comment">[2, 7, 11, 15]</span>, target = 9<br>因为 nums<span class="hljs-comment">[0]</span> + nums<span class="hljs-comment">[1]</span> = 2 + 7 = 9<br>所以返回 <span class="hljs-comment">[0, 1]</span><br></code></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>建立一个哈希表储存元素，每次新来的元素到哈希表里找有没有<code>target - nums[i]</code>这个元素。如果有，那么就找到了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-comment">//建立哈希表</span><br>        HashMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-comment">//如果哈希表里已经包含了另一个数，就找到这两个数了</span><br>            <span class="hljs-keyword">if</span>(map.containsKey(target - nums[i])) &#123;<br>                <span class="hljs-comment">//题目说每种输入只会对应一个答案，所以直接返回</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;map.get(target - nums[i]), i&#125;;<br>            &#125;<br>            <span class="hljs-comment">//这次没找到就把这次的值放进哈希表</span><br>            map.put(nums[i], i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">2</span>];<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="/posts/26794/1.JPG"></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数组</tag>
      
      <tag>哈希表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/posts/16107.html"/>
    <url>/posts/16107.html</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span> <h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>你好啊<br>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hello-World</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
